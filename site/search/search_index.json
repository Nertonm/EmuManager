{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"EmuManager","text":"<p>EmuManager \u00e9 uma ferramenta completa para organizar, validar e gerenciar cole\u00e7\u00f5es de emula\u00e7\u00e3o. Originalmente focado em Nintendo Switch, agora evoluiu para suportar m\u00faltiplos sistemas (GameCube, Wii, PS2, PS3, PSP) e oferecer uma interface gr\u00e1fica moderna.</p>"},{"location":"#recursos-principais","title":"Recursos Principais","text":""},{"location":"#interface-grafica-gui","title":"Interface Gr\u00e1fica (GUI)","text":"<ul> <li>Tema Escuro Moderno: Interface limpa e organizada com abas.</li> <li>Gerenciamento de Biblioteca:<ul> <li>Inicialize a estrutura de pastas padr\u00e3o (<code>roms/</code>, <code>bios/</code>, etc.).</li> <li>Liste e adicione ROMs facilmente (com detec\u00e7\u00e3o autom\u00e1tica de sistema).</li> <li>Suporte a subpastas (ex: <code>A-M/</code>, <code>N-Z/</code>).</li> </ul> </li> <li>Ferramentas de Manuten\u00e7\u00e3o:<ul> <li>Organize: Move e renomeia ROMs automaticamente baseando-se em metadados.<ul> <li>Switch: Baseado em <code>nstool</code>/<code>hactool</code>.</li> <li>GameCube/Wii: Baseado em cabe\u00e7alho interno e banco de dados (GameTDB).</li> <li>PS2: Identifica Serial (ex: <code>SLUS-20002</code>) e renomeia.</li> </ul> </li> <li>Health Check: Verifica integridade de arquivos e escaneia por v\u00edrus (ClamAV).</li> <li>Deep Verify: Verifica\u00e7\u00e3o profunda de hash (MD5/SHA1) para garantir integridade 1:1.<ul> <li>Suporte a DATs: Valida\u00e7\u00e3o contra arquivos <code>.dat</code> (No-Intro/Redump) com tabela de resultados detalhada (Status, CRC32, SHA1).</li> </ul> </li> <li>Clean Junk: Remove arquivos desnecess\u00e1rios (<code>.txt</code>, <code>.nfo</code>, <code>.url</code>) e pastas vazias.</li> </ul> </li> <li>Configura\u00e7\u00f5es Avan\u00e7adas:<ul> <li>Processamento Seletivo: Aplique a\u00e7\u00f5es apenas aos arquivos selecionados na lista.</li> <li>Padroniza\u00e7\u00e3o de Nomes: Force um padr\u00e3o de nomenclatura estrito (ex: adicionar Regi\u00e3o ao nome do arquivo).</li> </ul> </li> <li>Compress\u00e3o e Convers\u00e3o:<ul> <li>Switch: Comprima/Descomprima (<code>.nsp</code> &lt;-&gt; <code>.nsz</code>, <code>.xci</code> &lt;-&gt; <code>.xcz</code>).</li> <li>GameCube/Wii: Converta ISO para RVZ (formato moderno do Dolphin).</li> <li>PS1: Converta BIN/CUE/ISO para CHD.</li> <li>PS2: Converta ISO/CSO para CHD.</li> <li>PSP: Converta ISO para CSO.</li> </ul> </li> </ul>"},{"location":"#barra-de-menu-toolbar-e-atalhos","title":"Barra de Menu, Toolbar e Atalhos","text":"<ul> <li>Menu superior (File / Tools / View): a\u00e7\u00f5es reutiliz\u00e1veis entre menu e toolbar.</li> <li>Toolbar: bot\u00f5es r\u00e1pidos para Abrir Biblioteca, Atualizar Lista, Init, Add ROM, Verificar DAT, Cancelar, Alternar Log e Focar Filtro.</li> <li>Atalhos de teclado:</li> <li>Ctrl+O: Abrir Biblioteca</li> <li>F5: Atualizar Lista</li> <li>Ctrl+I: Inicializar Estrutura</li> <li>Ctrl+A: Adicionar ROM</li> <li>Ctrl+Shift+V: Verificar DAT</li> <li>Esc: Cancelar tarefa atual</li> <li>Ctrl+L: Alternar visibilidade do Log (dock)</li> <li>Ctrl+F: Focar o filtro de ROMs</li> <li>Enter/Return na lista de ROMs: Comprimir ROM selecionada</li> <li>Duplo clique na ROM: Comprimir</li> <li>Duplo clique em resultado de verifica\u00e7\u00e3o: Abrir pasta do arquivo</li> </ul>"},{"location":"#persistencia-do-layout-e-estado","title":"Persist\u00eancia do Layout e Estado","text":"<ul> <li>QSettings: janela, estado dos docks, visibilidade da toolbar, posi\u00e7\u00e3o do splitter, larguras das colunas da verifica\u00e7\u00e3o, texto do filtro e \u00faltimo sistema selecionado s\u00e3o restaurados entre sess\u00f5es.</li> <li>View &gt; Reset Layout: limpa as prefer\u00eancias salvas e restaura o layout padr\u00e3o.</li> </ul>"},{"location":"#verificacao-dat-e-csv","title":"Verifica\u00e7\u00e3o (DAT) e CSV","text":"<ul> <li>Tabela de resultados com ordena\u00e7\u00e3o (clicar no cabe\u00e7alho) e filtros r\u00e1pidos: All, VERIFIED, UNKNOWN.</li> <li>Export CSV: exporta respeitando o filtro atual e inclui caminho completo do arquivo.</li> <li>Abrir local: duplo clique em uma linha abre a pasta do ROM.</li> </ul>"},{"location":"#verificacao-e-hashing-detalhes","title":"Verifica\u00e7\u00e3o e Hashing (detalhes)","text":"<ul> <li>Hashes calculados: por padr\u00e3o <code>CRC32</code> e <code>SHA1</code> para desempenho e precis\u00e3o.</li> <li>Deep Verify: ativa tamb\u00e9m <code>MD5</code> e <code>SHA256</code> para valida\u00e7\u00e3o mais forte.</li> <li>Status MISMATCH: se o <code>CRC32</code> corresponde a entradas do DAT mas <code>MD5/SHA1</code> n\u00e3o, o arquivo \u00e9 marcado como MISMATCH e o nome esperado \u00e9 exibido quando dispon\u00edvel.</li> <li>Atalhos de contexto na tabela de verifica\u00e7\u00e3o:<ul> <li>Abrir pasta do arquivo</li> <li>Copiar <code>CRC32</code>, <code>SHA1</code>, <code>MD5</code>, <code>SHA256</code></li> </ul> </li> </ul>"},{"location":"#cli-linha-de-comando","title":"CLI (Linha de Comando)","text":"<p>O m\u00f3dulo <code>emumanager</code> tamb\u00e9m pode ser usado via terminal para automa\u00e7\u00e3o e scripts. O script legado <code>switch_organizer.py</code> ainda est\u00e1 dispon\u00edvel para compatibilidade, mas o foco agora \u00e9 o pacote <code>emumanager</code>.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>PS2 Identification: New module <code>emumanager.ps2</code> to extract Serials from ISO/BIN/GZ files and identify games.</li> <li>PS2 Database: Simple CSV-based database support (<code>ps2_db.csv</code>) for game title lookup.</li> <li>GUI: New \"Identify &amp; Verify Games\" button in the PS2 tab.</li> <li>Refactoring: Extracted <code>process_files(files, ctx)</code> into <code>emumanager.switch.main_helpers</code>.</li> <li>Introduced small helpers: <code>build_new_filename</code>, <code>get_dest_folder</code>, <code>make_catalog_entry</code>.</li> <li>New unit tests added: <code>tests/test_main_helpers.py</code> covering the new helpers.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Cleanup: Removed <code>emumanager/legacy</code> and moved useful code to <code>emumanager/switch</code>.</li> <li>Refactoring: <code>switch_organizer.py</code> now builds a context dict and delegates file processing to <code>emumanager.switch.main_helpers.process_files</code>.</li> <li>Refactoring: Improved <code>gui_main.py</code> by extracting dialog logic and background task management.</li> <li>Refactoring: Centralized tool finding logic in <code>emumanager.common.execution</code>.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Adjusted test suite and fixed issues surfaced by refactor; full test suite passing.</li> <li>Fixed PS2 Converter worker to correctly pass tool paths.</li> </ul>"},{"location":"changelog/#010-2025-12-22","title":"[0.1.0] - 2025-12-22","text":"<ul> <li>Initial public refactor and packaging efforts.</li> </ul>"},{"location":"configuration/","title":"Configura\u00e7\u00e3o","text":"<p>O EmuManager salva suas configura\u00e7\u00f5es automaticamente usando <code>QSettings</code> (Qt).</p>"},{"location":"configuration/#configuracoes-da-interface","title":"Configura\u00e7\u00f5es da Interface","text":"<p>As seguintes configura\u00e7\u00f5es s\u00e3o persistidas entre sess\u00f5es:</p> <ul> <li>Tamanho e Posi\u00e7\u00e3o da Janela: A janela reabrir\u00e1 no mesmo lugar e tamanho.</li> <li>Layout: A posi\u00e7\u00e3o dos pain\u00e9is (Log, etc.) \u00e9 salva.</li> <li>\u00daltima Biblioteca: A \u00faltima pasta de biblioteca aberta ser\u00e1 lembrada.</li> <li>Filtros: O \u00faltimo filtro de texto e filtro de verifica\u00e7\u00e3o s\u00e3o salvos.</li> </ul>"},{"location":"configuration/#configuracoes-de-processamento","title":"Configura\u00e7\u00f5es de Processamento","text":"<p>Na aba \"Settings\" (ou checkboxes na interface principal), voc\u00ea pode configurar:</p> <ul> <li>Dry Run: Simula as opera\u00e7\u00f5es sem fazer altera\u00e7\u00f5es reais.</li> <li>Compression Level: N\u00edvel de compress\u00e3o para ferramentas que suportam (ex: NSZ).</li> <li>Remove Originals: Se marcado, remove os arquivos originais ap\u00f3s compress\u00e3o/convers\u00e3o bem-sucedida.</li> <li>Quarantine: Move arquivos corrompidos ou desconhecidos para uma pasta <code>_QUARANTINE</code>.</li> <li>Deep Verify: Ativa verifica\u00e7\u00e3o MD5 e SHA256 (mais lento, mas mais seguro).</li> <li>Recursive: Processa subpastas recursivamente.</li> <li>Process Selected: Aplica a\u00e7\u00f5es apenas aos itens selecionados na lista.</li> <li>Standardize Names: Renomeia arquivos seguindo um padr\u00e3o estrito (ex: <code>Nome do Jogo (Regi\u00e3o) (Serial).ext</code>).</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thanks for considering contributing! This file contains a short guide to get you started.</p>"},{"location":"contributing/#development-setup","title":"Development setup","text":"<ol> <li>Create and activate a virtual environment:</li> </ol> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt  # optional\n</code></pre> <ol> <li>Install the package in editable mode:</li> </ol> <pre><code>python -m pip install -e .\n</code></pre> <ol> <li>(Optional) Install GUI extras if you plan to run the GUI:</li> </ol> <pre><code>python -m pip install pyqt6\n# or if the project exposes extras: python -m pip install -e .[gui]\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<p>Run the test suite with pytest:</p> <pre><code>python -m pytest -q\n</code></pre> <p>The repository includes a headless GUI smoke test (<code>tests/test_gui_smoke.py</code>) that requires <code>xvfb-run</code> or an X server.</p>"},{"location":"contributing/#linting-and-formatting","title":"Linting and formatting","text":"<p>We recommend using <code>ruff</code> for linting and <code>black</code> for formatting (if desired):</p> <pre><code>python -m pip install ruff black\nruff check .\nblack .\n</code></pre> <p>Keep changes small and focused. Add tests for new features and ensure the CI passes before opening a PR.</p>"},{"location":"contributing/#submitting-changes","title":"Submitting changes","text":"<ul> <li>Fork the repository.</li> <li>Create a branch with a meaningful name (e.g., <code>fix/ci-gui-smoke</code>).</li> <li>Commit small changes with clear messages.</li> <li>Open a pull request with a description of what you changed and why.</li> </ul> <p>Thank you!</p>"},{"location":"contributing/#contribuindo-portugues","title":"Contribuindo (Portugu\u00eas)","text":"<p>Obrigado por querer contribuir! Algumas orienta\u00e7\u00f5es r\u00e1pidas:</p> <ul> <li>Abra uma issue para discutir mudan\u00e7as grandes antes de implementar.</li> <li>Use branches com nomes descritivos (ex.: feature/organize-refactor, fix/typo-readme).</li> <li>Sempre rode os testes localmente antes de abrir um pull request:</li> </ul> <pre><code>. .venv/bin/activate\npython -m pytest -q\n</code></pre> <ul> <li>Escreva testes para novos recursos e mantenha o estilo do projeto.</li> <li>Siga as conven\u00e7\u00f5es do PEP8; recomendo usar <code>ruff</code> ou <code>black</code> para formata\u00e7\u00e3o.</li> </ul> <p>Ao enviar um PR, inclua uma descri\u00e7\u00e3o curta do que foi alterado e o motivo.</p>"},{"location":"installation/","title":"Instala\u00e7\u00e3o","text":""},{"location":"installation/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>Python 3.8+</li> <li>Ferramentas Externas (necess\u00e1rias para recursos espec\u00edficos):<ul> <li>Switch: <code>nstool</code> ou <code>hactool</code> (Metadados), <code>nsz</code> (Compress\u00e3o).</li> <li>GameCube/Wii: <code>dolphin-tool</code> (parte do emulador Dolphin).</li> <li>PS2: <code>maxcso</code> e <code>chdman</code> (parte do MAME).</li> <li>Antiv\u00edrus: <code>clamscan</code> (ClamAV).</li> </ul> </li> </ul>"},{"location":"installation/#configuracao-rapida-automatica","title":"Configura\u00e7\u00e3o R\u00e1pida (Autom\u00e1tica)","text":"<p>O projeto inclui um script de bootstrap que instala depend\u00eancias do sistema (Debian/Ubuntu e Arch Linux), compila ferramentas necess\u00e1rias (como <code>hactool</code>) e configura o ambiente Python.</p> <ol> <li> <p>Clone o reposit\u00f3rio: <code>bash    git clone https://github.com/Nertonm/EmuManager.git    cd EmuManager</code></p> </li> <li> <p>Execute o script de instala\u00e7\u00e3o: <code>bash    chmod +x scripts/bootstrap.sh    ./scripts/bootstrap.sh</code> O script solicitar\u00e1 senha <code>sudo</code> para instalar pacotes do sistema e copiar bin\u00e1rios para <code>/usr/local/bin</code>.</p> </li> <li> <p>Ative o ambiente e execute: <code>bash    source .venv/bin/activate    python -m emumanager.gui</code></p> </li> </ol>"},{"location":"installation/#instalacao-manual","title":"Instala\u00e7\u00e3o Manual","text":"<p>Se preferir n\u00e3o usar o script de bootstrap:</p> <ol> <li> <p>Crie um ambiente virtual: <code>bash    python3 -m venv .venv    source .venv/bin/activate</code></p> </li> <li> <p>Instale as depend\u00eancias: <code>bash    pip install -r requirements.txt    pip install -e .</code></p> </li> <li> <p>Instale as ferramentas externas:</p> </li> <li>Debian/Ubuntu: <code>bash      sudo apt install clamav dolphin-emu-utils mame-tools</code></li> <li>Arch Linux: <code>bash      sudo pacman -S clamav dolphin-emu mame-tools</code></li> <li>Switch Tools: Voc\u00ea precisar\u00e1 compilar ou baixar <code>hactool</code>, <code>nstool</code> e <code>nsz</code> manualmente e coloc\u00e1-los no PATH.</li> </ol>"},{"location":"usage/","title":"Uso","text":""},{"location":"usage/#interface-grafica-gui","title":"Interface Gr\u00e1fica (GUI)","text":"<p>Para iniciar a interface gr\u00e1fica:</p> <pre><code>python -m emumanager.gui\n</code></pre>"},{"location":"usage/#primeiros-passos","title":"Primeiros Passos","text":"<ol> <li>Abrir Biblioteca: Clique em \"Open Library\" e selecione a pasta raiz onde voc\u00ea deseja organizar seus jogos.</li> <li>Inicializar: Se for a primeira vez, clique em \"Init\" para criar a estrutura de pastas padr\u00e3o (<code>roms/</code>, <code>bios/</code>, etc.).</li> <li>Adicionar Jogos: Clique em \"Add ROM\" para adicionar um jogo \u00e0 sua biblioteca. O sistema tentar\u00e1 detectar automaticamente o console.</li> <li>Organizar: Clique em \"Organize\" para organizar automaticamente os jogos nas pastas corretas e renome\u00e1-los.</li> </ol>"},{"location":"usage/#verificacao-de-integridade","title":"Verifica\u00e7\u00e3o de Integridade","text":"<ol> <li>Selecionar DAT: V\u00e1 para a aba \"Verification\" e selecione um arquivo <code>.dat</code> (No-Intro ou Redump).</li> <li>Verificar: Clique em \"Verify DAT\" para verificar seus jogos contra o arquivo DAT.</li> <li>Resultados: A tabela mostrar\u00e1 quais jogos est\u00e3o verificados (verde) e quais t\u00eam problemas (vermelho).</li> </ol>"},{"location":"usage/#linha-de-comando-cli","title":"Linha de Comando (CLI)","text":"<p>O <code>emumanager</code> tamb\u00e9m pode ser usado via linha de comando.</p> <pre><code># Ver ajuda\nemumanager --help\n\n# Inicializar biblioteca\nemumanager init /caminho/para/biblioteca\n\n# Listar sistemas\nemumanager list /caminho/para/biblioteca\n\n# Adicionar ROM\nemumanager add /caminho/para/rom.iso /caminho/para/biblioteca --system ps2\n</code></pre>"},{"location":"reference/architect/","title":"Architect API","text":""},{"location":"reference/architect/#emumanager.architect","title":"<code>emumanager.architect</code>","text":"<p>Architect module (package version)</p> <p>This file is a near-copy of the previous <code>scripts/architect_roms_master.py</code> but lives inside the <code>emumanager</code> package. It keeps the same public API (main, build_acervo, etc.) so existing code and tests keep working.</p>"},{"location":"reference/architect/#emumanager.architect.GracefulExit","title":"<code>GracefulExit</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the program should exit gracefully due to a signal.</p> Source code in <code>emumanager/architect.py</code> <pre><code>class GracefulExit(Exception):\n    \"\"\"Raised when the program should exit gracefully due to a signal.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/architect/#emumanager.architect.get_roms_dir","title":"<code>get_roms_dir(base_dir)</code>","text":"<p>Resolve the roms directory given a base path.</p> Source code in <code>emumanager/architect.py</code> <pre><code>def get_roms_dir(base_dir: Path) -&gt; Path:\n    \"\"\"Resolve the roms directory given a base path.\"\"\"\n    # If base_dir is already the 'roms' folder, use it directly\n    if base_dir.name == \"roms\":\n        return base_dir\n    # Otherwise, append 'roms'\n    return base_dir / \"roms\"\n</code></pre>"},{"location":"reference/gui/","title":"GUI API","text":""},{"location":"reference/gui/#emumanager.gui_main","title":"<code>emumanager.gui_main</code>","text":"<p>MainWindow component for EmuManager GUI.</p> <p>This module contains the MainWindow class and related UI helpers. It is GUI-library-agnostic in the sense that callers should import the Qt classes from the binding they prefer and pass them when constructing the window.</p>"},{"location":"reference/gui/#emumanager.gui_main.MainWindowBase","title":"<code>MainWindowBase</code>","text":"<p>A minimal abstraction over a Qt MainWindow used by the package.</p> <p>This class expects the QtWidgets module to be available in the global namespace of the caller (i.e., the module that instantiates it).</p> Source code in <code>emumanager/gui_main.py</code> <pre><code>class MainWindowBase:\n    \"\"\"A minimal abstraction over a Qt MainWindow used by the package.\n\n    This class expects the QtWidgets module to be available in the global\n    namespace of the caller (i.e., the module that instantiates it).\n    \"\"\"\n\n    def __init__(self, qtwidgets: Any, manager_module: Any):\n        self._qtwidgets = qtwidgets\n        self._manager = manager_module\n        self.ui = Ui_MainWindow()\n        self._last_base = None\n        self._current_dat_path = None\n\n        # Create widgets (use local alias to the qt binding)\n        qt = self._qtwidgets\n        # Common literals\n        self._dlg_select_base_title = \"Select base directory\"\n\n        # Attempt to locate the QtCore module corresponding to the passed\n        # QtWidgets binding (works for PyQt6 or PySide6). Also prepare a small\n        # thread pool used for background tasks.\n        try:\n            import importlib\n\n            try:\n                self._qtcore = importlib.import_module(\"PyQt6.QtCore\")\n                self._qtgui = importlib.import_module(\"PyQt6.QtGui\")\n            except Exception:\n                self._qtcore = importlib.import_module(\"PySide6.QtCore\")\n                self._qtgui = importlib.import_module(\"PySide6.QtGui\")\n        except Exception:\n            self._qtcore = None\n            self._qtgui = None\n\n        # Executor for background tasks (small pool)\n        try:\n            import concurrent.futures\n\n            self._executor = concurrent.futures.ThreadPoolExecutor(max_workers=2)\n        except Exception:\n            self._executor = None\n\n        # UI state helpers\n        self._active_timer = None\n        self._active_future = None\n        self._cancel_event = threading.Event()\n        self._settings = None\n        self._last_base = None\n        self._env = {}  # Cache for environment tools/paths\n        self.window = qt.QMainWindow()\n\n        # Setup UI\n        self.ui.setupUi(self.window, qt)\n\n        # Setup close handler\n        self._original_close_event = self.window.closeEvent\n        self.window.closeEvent = self._on_close_event\n\n        # Alias common widgets for convenience and compatibility\n        self.log = self.ui.log\n        self.status = self.ui.statusbar\n        self.rom_list = self.ui.rom_list\n        self.sys_list = self.ui.sys_list\n        self.cover_label = self.ui.cover_label\n\n        # Alias settings widgets\n        self.chk_dry_run = self.ui.chk_dry_run\n        self.spin_level = self.ui.spin_level\n        self.combo_profile = self.ui.combo_profile\n        self.chk_rm_originals = self.ui.chk_rm_originals\n        self.chk_quarantine = self.ui.chk_quarantine\n        self.chk_deep_verify = self.ui.chk_deep_verify\n        self.chk_recursive = self.ui.chk_recursive\n        self.chk_process_selected = self.ui.chk_process_selected\n        self.chk_standardize_names = self.ui.chk_standardize_names\n\n        if self._qtgui:\n            self.ui.apply_dark_theme(qt, self._qtgui, self.window)\n\n        # Setup thread-safe logging signal\n        if self._qtcore:\n            # Define a QObject to hold the signal\n            class LogSignaler(self._qtcore.QObject):\n                # Try both PyQt6 and PySide6 signal names\n                if hasattr(self._qtcore, \"pyqtSignal\"):\n                    log_signal = self._qtcore.pyqtSignal(str)\n                    progress_signal = self._qtcore.pyqtSignal(float, str)\n                else:\n                    log_signal = self._qtcore.Signal(str)\n                    progress_signal = self._qtcore.Signal(float, str)\n\n                def emit_log(self, msg, level):\n                    # We can optionally use level to colorize, but for now just emit msg\n                    self.log_signal.emit(msg)\n\n            self._signaler = LogSignaler()\n            self._signaler.log_signal.connect(self._log_msg_slot)\n            self._signaler.progress_signal.connect(self._progress_slot)\n\n            # Configure standard logging to use this signaler\n            setup_gui_logging(self._signaler)\n\n        else:\n            self._signaler = None\n\n        # Initialize logger\n        self.logger = get_logger(\"gui\")\n\n        # Initialize Controllers\n        self.gallery_controller = GalleryController(self)\n        self.tools_controller = ToolsController(self)\n\n        # Connect Signals\n        self._connect_signals()\n\n        # Initialize settings if possible\n        if self._qtcore:\n            self._settings = self._qtcore.QSettings(\"EmuManager\", \"Manager\")\n            self._load_settings()\n\n        # Resolve Qt namespace for enums\n        self._Qt_enum = None\n        if self._qtcore:\n            try:\n                self._Qt_enum = self._qtcore.Qt\n            except AttributeError:\n                pass\n\n        # Enhance UI: toolbar and context menus\n        try:\n            self._setup_toolbar()\n            self._setup_menubar()\n            self._setup_rom_context_menu()\n            self._setup_verification_context_menu()\n        except Exception:\n            pass\n\n        # Setup smart startup hook\n        if self._qtcore:\n            self._setup_startup_hook()\n\n    def _setup_startup_hook(self):\n        \"\"\"\n        Install an event filter to trigger logic only when the window is actually shown.\n        \"\"\"\n        QObject = self._qtcore.QObject\n\n        # Define filter class dynamically to use the imported QObject\n        class StartupFilter(QObject):\n            def __init__(self, callback):\n                super().__init__()\n                self.callback = callback\n                self.has_run = False\n\n            def eventFilter(self, obj, event):\n                # Check for Show event (17)\n                # Handle both PyQt6 (enum) and PySide6 (int/enum)\n                t = event.type()\n                val = t.value if hasattr(t, \"value\") else t\n\n                if val == 17:  # QEvent.Show\n                    if not self.has_run:\n                        self.has_run = True\n                        self.callback()\n                return False\n\n        self._startup_filter = StartupFilter(self._on_ui_shown)\n        self.window.installEventFilter(self._startup_filter)\n\n    def _on_ui_shown(self):\n        \"\"\"Called when the window receives the Show event.\"\"\"\n        # Defer slightly to ensure the window is fully painted and event loop is running\n        self._qtcore.QTimer.singleShot(100, self._startup_logic)\n\n    def _startup_logic(self):\n        \"\"\"Perform startup checks: load last library or prompt user.\"\"\"\n        if self._last_base and self._last_base.exists():\n            self.log_msg(f\"Library ready: {self._last_base}\")\n            self.on_list()\n        else:\n            self.log_msg(\"Welcome! Please select a library.\")\n            self.on_open_library()\n\n    def _connect_signals(self):\n        # Dashboard Tab\n        if hasattr(self.ui, \"btn_quick_organize\"):\n            self.ui.btn_quick_organize.clicked.connect(self.on_organize_all)\n        if hasattr(self.ui, \"btn_quick_verify\"):\n            self.ui.btn_quick_verify.clicked.connect(self.on_verify_all)\n        if hasattr(self.ui, \"btn_quick_update\"):\n            self.ui.btn_quick_update.clicked.connect(self.on_list)\n\n        # Library Tab\n        self.ui.btn_open_lib.clicked.connect(self.on_open_library)\n        self.ui.btn_init.clicked.connect(self.on_init)\n        self.ui.btn_list.clicked.connect(self.on_list)\n        self.ui.btn_add.clicked.connect(self.on_add)\n        self.ui.btn_clear.clicked.connect(self.on_clear_log)\n        # Connect selection change for covers\n        self.ui.rom_list.currentItemChanged.connect(self._on_rom_selection_changed)\n        # Filter box\n        if hasattr(self.ui, \"edit_filter\"):\n            self.ui.edit_filter.textChanged.connect(self._on_filter_text)\n        if hasattr(self.ui, \"btn_clear_filter\"):\n            self.ui.btn_clear_filter.clicked.connect(\n                lambda: self.ui.edit_filter.setText(\"\")\n            )\n        self.ui.sys_list.itemClicked.connect(self._on_system_selected)\n        self.ui.rom_list.itemDoubleClicked.connect(self._on_rom_double_clicked)\n\n        # Cancel button\n        self.ui.btn_cancel.clicked.connect(self.on_cancel_requested)\n\n        # Verification Tab\n        self.ui.btn_select_dat.clicked.connect(self.on_select_dat)\n        self.ui.btn_verify_dat.clicked.connect(self.on_verify_dat)\n        if hasattr(self.ui, \"btn_update_dats\"):\n            self.ui.btn_update_dats.clicked.connect(self.on_update_dats)\n        if hasattr(self.ui, \"combo_verif_filter\"):\n            self.ui.combo_verif_filter.currentTextChanged.connect(\n                self.on_verification_filter_changed\n            )\n        if hasattr(self.ui, \"btn_export_csv\"):\n            self.ui.btn_export_csv.clicked.connect(self.on_export_verification_csv)\n        # Key handling on ROM list (Enter/Return to Compress)\n        try:\n            self._install_rom_key_filter()\n        except Exception:\n            pass\n        if hasattr(self.ui, \"table_results\"):\n            self.ui.table_results.itemDoubleClicked.connect(\n                self._on_verification_item_dblclick\n            )\n        if hasattr(self.ui, \"combo_verif_filter\"):\n            self.ui.combo_verif_filter.currentTextChanged.connect(\n                self.on_verification_filter_changed\n            )\n        if hasattr(self.ui, \"btn_export_csv\"):\n            self.ui.btn_export_csv.clicked.connect(self.on_export_verification_csv)\n        if hasattr(self.ui, \"btn_identify_all\"):\n            self.ui.btn_identify_all.clicked.connect(self.on_identify_all)\n\n    def show(self):\n        self.window.show()\n\n    def _log_msg_slot(self, text: str):\n        # Just append to the log window.\n        # The text is already formatted by the logging handler if it came from there.\n        self.log.append(text)\n        # Show brief status in the status bar\n        try:\n            self.status.showMessage(text, 5000)\n        except Exception:\n            pass\n\n    def _progress_slot(self, percent: float, message: str):\n        try:\n            # clamp percent\n            p = 0.0 if percent is None else float(percent)\n            if p &lt; 0.0:\n                p = 0.0\n            if p &gt; 1.0:\n                p = 1.0\n\n            # Update progress bar\n            try:\n                if not self.ui.progress_bar.isVisible():\n                    self.ui.progress_bar.setVisible(True)\n                self.ui.progress_bar.setValue(int(p * 100))\n            except Exception:\n                pass\n\n            if message:\n                self.status.showMessage(message)\n        except Exception:\n            pass\n\n    def log_msg(self, text: str):\n        \"\"\"Thread-safe logging method.\n\n        Now redirects to standard logging.\n        \"\"\"\n        logging.info(text)\n\n    def on_clear_log(self):\n        try:\n            self.log.clear()\n        except Exception:\n            # ignore GUI errors\n            pass\n\n    def _ensure_common_actions(self):\n        \"\"\"Create common QAction objects once and store as instance attributes.\"\"\"\n        qt = self._qtwidgets\n        if hasattr(self, \"act_open_library\"):\n            return\n        # grouped creators to reduce complexity\n        self._create_file_actions(qt)\n        self._create_view_actions(qt)\n        self._create_tools_actions(qt)\n        self._create_misc_actions(qt)\n\n    def _create_file_actions(self, qt):\n        self.act_open_library = qt.QAction(\"Open Library\", self.window)\n        self.act_open_library.setShortcut(\"Ctrl+O\")\n        self.act_open_library.triggered.connect(self.on_open_library)\n\n        self.act_refresh_list = qt.QAction(\"Refresh List\", self.window)\n        self.act_refresh_list.setShortcut(\"F5\")\n        self.act_refresh_list.triggered.connect(self.on_list)\n\n        self.act_init_structure = qt.QAction(\"Init Structure\", self.window)\n        self.act_init_structure.setShortcut(\"Ctrl+I\")\n        self.act_init_structure.triggered.connect(self.on_init)\n\n        self.act_add_rom = qt.QAction(\"Add ROM\", self.window)\n        self.act_add_rom.setShortcut(\"Ctrl+A\")\n        self.act_add_rom.triggered.connect(self.on_add)\n\n        self.act_verify_dat = qt.QAction(\"Verify DAT\", self.window)\n        self.act_verify_dat.setShortcut(\"Ctrl+Shift+V\")\n        self.act_verify_dat.triggered.connect(self.on_verify_dat)\n\n        self.act_cancel = qt.QAction(\"Cancel\", self.window)\n        self.act_cancel.setShortcut(\"Esc\")\n        self.act_cancel.triggered.connect(self.on_cancel_requested)\n\n        self.act_exit = qt.QAction(\"Exit\", self.window)\n        self.act_exit.setShortcut(\"Ctrl+Q\")\n\n        def _exit():\n            try:\n                self.window.close()\n            except Exception:\n                pass\n\n        self.act_exit.triggered.connect(_exit)\n\n    def _create_view_actions(self, qt):\n        self.act_toggle_log = qt.QAction(\"Toggle Log\", self.window)\n        self.act_toggle_log.setShortcut(\"Ctrl+L\")\n\n        def _toggle_log():\n            try:\n                vis = self.ui.log_dock.isVisible()\n                self.ui.log_dock.setVisible(not vis)\n            except Exception:\n                pass\n\n        self.act_toggle_log.triggered.connect(_toggle_log)\n\n        self.act_toggle_toolbar = qt.QAction(\"Show Toolbar\", self.window)\n        try:\n            self.act_toggle_toolbar.setCheckable(True)\n        except Exception:\n            pass\n\n        def _toggle_tb(checked=None):\n            try:\n                tb = getattr(self, \"_toolbar\", None)\n                if tb:\n                    if checked is None:\n                        vis = tb.isVisible()\n                        tb.setVisible(not vis)\n                    else:\n                        tb.setVisible(bool(checked))\n            except Exception:\n                pass\n\n        self.act_toggle_toolbar.triggered.connect(_toggle_tb)\n\n        self.act_focus_filter = qt.QAction(\"Focus ROM Filter\", self.window)\n        self.act_focus_filter.setShortcut(\"Ctrl+F\")\n\n        def _focus_filter():\n            try:\n                if hasattr(self.ui, \"edit_filter\"):\n                    self.ui.edit_filter.setFocus()\n            except Exception:\n                pass\n\n        self.act_focus_filter.triggered.connect(_focus_filter)\n\n        # Reset layout\n        self.act_reset_layout = qt.QAction(\"Reset Layout\", self.window)\n        self.act_reset_layout.triggered.connect(self._reset_layout)\n\n    def _create_tools_actions(self, qt):\n        self.act_organize = qt.QAction(\"Organize Library\", self.window)\n        self.act_organize.triggered.connect(self.tools_controller.on_organize)\n\n        self.act_health = qt.QAction(\"Health Check\", self.window)\n        self.act_health.triggered.connect(self.tools_controller.on_health_check)\n\n        self.act_switch_compress = qt.QAction(\"Switch: Compress\", self.window)\n        self.act_switch_compress.triggered.connect(\n            self.tools_controller.on_switch_compress\n        )\n\n        self.act_switch_decompress = qt.QAction(\"Switch: Decompress\", self.window)\n        self.act_switch_decompress.triggered.connect(\n            self.tools_controller.on_switch_decompress\n        )\n\n        self.act_ps2_convert = qt.QAction(\"PS2: Convert to CHD\", self.window)\n        self.act_ps2_convert.triggered.connect(self.tools_controller.on_ps2_convert)\n\n        self.act_psx_convert = qt.QAction(\"PS1: Convert to CHD\", self.window)\n        self.act_psx_convert.triggered.connect(self.tools_controller.on_psx_convert)\n\n        self.act_ps2_verify = qt.QAction(\"PS2: Verify\", self.window)\n        self.act_ps2_verify.triggered.connect(self.tools_controller.on_ps2_verify)\n\n        self.act_psx_verify = qt.QAction(\"PS1: Verify\", self.window)\n        self.act_psx_verify.triggered.connect(self.tools_controller.on_psx_verify)\n\n        self.act_ps2_organize = qt.QAction(\"PS2: Organize\", self.window)\n        self.act_ps2_organize.triggered.connect(self.tools_controller.on_ps2_organize)\n\n        self.act_psx_organize = qt.QAction(\"PS1: Organize\", self.window)\n        self.act_psx_organize.triggered.connect(self.tools_controller.on_psx_organize)\n\n        self.act_ps3_verify = qt.QAction(\"PS3: Verify\", self.window)\n        self.act_ps3_verify.triggered.connect(self.tools_controller.on_ps3_verify)\n\n        self.act_ps3_organize = qt.QAction(\"PS3: Organize\", self.window)\n        self.act_ps3_organize.triggered.connect(self.tools_controller.on_ps3_organize)\n\n        self.act_psp_verify = qt.QAction(\"PSP: Verify\", self.window)\n        self.act_psp_verify.triggered.connect(self.tools_controller.on_psp_verify)\n\n        self.act_psp_organize = qt.QAction(\"PSP: Organize\", self.window)\n        self.act_psp_organize.triggered.connect(self.tools_controller.on_psp_organize)\n\n        self.act_psp_compress = qt.QAction(\"PSP: Compress ISO-&gt;CSO\", self.window)\n        self.act_psp_compress.triggered.connect(self.tools_controller.on_psp_compress)\n\n        self.act_n3ds_verify = qt.QAction(\"3DS: Verify\", self.window)\n        self.act_n3ds_verify.triggered.connect(self.tools_controller.on_n3ds_verify)\n\n        self.act_n3ds_organize = qt.QAction(\"3DS: Organize\", self.window)\n        self.act_n3ds_organize.triggered.connect(self.tools_controller.on_n3ds_organize)\n\n        self.act_dol_convert = qt.QAction(\"GC/Wii: Convert to RVZ\", self.window)\n        self.act_dol_convert.triggered.connect(self.tools_controller.on_dolphin_convert)\n\n        self.act_dol_verify = qt.QAction(\"GC/Wii: Verify\", self.window)\n        self.act_dol_verify.triggered.connect(self.tools_controller.on_dolphin_verify)\n\n        self.act_dol_organize = qt.QAction(\"GC/Wii: Organize\", self.window)\n        self.act_dol_organize.triggered.connect(\n            self.tools_controller.on_dolphin_organize\n        )\n\n        self.act_clean_junk = qt.QAction(\"Clean Junk Files\", self.window)\n        self.act_clean_junk.triggered.connect(self.tools_controller.on_clean_junk)\n\n        self.act_export_csv = qt.QAction(\"Export Verification CSV\", self.window)\n        self.act_export_csv.triggered.connect(self.on_export_verification_csv)\n\n    def _create_misc_actions(self, qt):\n        self.act_open_folder = qt.QAction(\"Open Selected ROM Folder\", self.window)\n        self.act_open_folder.triggered.connect(self._open_selected_rom_folder)\n\n        self.act_copy_path = qt.QAction(\"Copy Selected ROM Path\", self.window)\n        self.act_copy_path.triggered.connect(self._copy_selected_rom_path)\n\n    def _setup_toolbar(self):\n        \"\"\"Create a toolbar with common actions and shortcuts.\n\n        Actions are created once and reused by both toolbar and menubar.\n        \"\"\"\n        qt = self._qtwidgets\n        try:\n            # Ensure actions exist\n            self._ensure_common_actions()\n            tb = qt.QToolBar(\"Main\")\n            self.window.addToolBar(tb)\n            self._toolbar = tb\n            # Actions\n            tb.addAction(self.act_open_library)\n            tb.addAction(self.act_refresh_list)\n            tb.addAction(self.act_init_structure)\n            tb.addAction(self.act_add_rom)\n            tb.addAction(self.act_verify_dat)\n            tb.addAction(self.act_cancel)\n            tb.addSeparator()\n            tb.addAction(self.act_toggle_log)\n            tb.addAction(self.act_focus_filter)\n        except Exception:\n            pass\n\n    def _setup_menubar(self):\n        \"\"\"Create the top menubar with File, Tools, and View menus.\"\"\"\n        qt = self._qtwidgets\n        try:\n            self._ensure_common_actions()\n            mb = qt.QMenuBar(self.window)\n            self.window.setMenuBar(mb)\n\n            # File menu\n            m_file = mb.addMenu(\"File\")\n            m_file.addAction(self.act_open_library)\n            m_file.addAction(self.act_refresh_list)\n            m_file.addAction(self.act_add_rom)\n            m_file.addSeparator()\n            m_file.addAction(self.act_exit)\n\n            # Tools menu\n            m_tools = mb.addMenu(\"Tools\")\n            m_tools.addAction(self.act_init_structure)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_organize)\n            m_tools.addAction(self.act_health)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_switch_compress)\n            m_tools.addAction(self.act_switch_decompress)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_psx_convert)\n            m_tools.addAction(self.act_psx_verify)\n            m_tools.addAction(self.act_psx_organize)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_ps2_convert)\n            m_tools.addAction(self.act_ps2_verify)\n            m_tools.addAction(self.act_ps2_organize)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_ps3_verify)\n            m_tools.addAction(self.act_ps3_organize)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_psp_verify)\n            m_tools.addAction(self.act_psp_organize)\n            m_tools.addAction(self.act_psp_compress)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_n3ds_verify)\n            m_tools.addAction(self.act_n3ds_organize)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_dol_convert)\n            m_tools.addAction(self.act_dol_verify)\n            m_tools.addAction(self.act_dol_organize)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_clean_junk)\n            m_tools.addSeparator()\n            m_tools.addAction(self.act_verify_dat)\n            m_tools.addAction(self.act_export_csv)\n\n            # View menu\n            m_view = mb.addMenu(\"View\")\n            m_view.addAction(self.act_toggle_log)\n            m_view.addAction(self.act_toggle_toolbar)\n            m_view.addSeparator()\n            m_view.addAction(self.act_focus_filter)\n            m_view.addSeparator()\n            m_view.addAction(self.act_reset_layout)\n        except Exception:\n            pass\n\n    def _setup_rom_context_menu(self):\n        \"\"\"Add a context menu to the ROM list for quick actions.\"\"\"\n        qt = self._qtwidgets\n        core = self._qtcore\n        try:\n            # Use QtCore.Qt for constants\n            Qt = core.Qt\n            policy = (\n                Qt.ContextMenuPolicy.CustomContextMenu\n                if hasattr(Qt, \"ContextMenuPolicy\")\n                else Qt.CustomContextMenu\n            )\n            self.ui.rom_list.setContextMenuPolicy(policy)\n\n            def _show_menu(pos):\n                try:\n                    menu = qt.QMenu(self.ui.rom_list)\n\n                    # Actions requested: Delete, Compress, Verify, Decompress\n                    a_del = menu.addAction(\"Delete\")\n                    menu.addSeparator()\n                    a_comp = menu.addAction(\"Compress\")\n                    a_recomp = menu.addAction(\"Recompress\")\n                    a_decomp = menu.addAction(\"Decompress\")\n                    menu.addSeparator()\n                    a_verify = menu.addAction(\"Verify (Calc Hash)\")\n                    a_identify = menu.addAction(\"Identify with DAT...\")\n                    menu.addSeparator()\n                    a_open = menu.addAction(\"Open Folder\")\n                    a_copy = menu.addAction(\"Copy Path\")\n\n                    # Use exec_ if available (PyQt5/PySide2), else exec (PyQt6/PySide6)\n                    exec_func = menu.exec if hasattr(menu, \"exec\") else menu.exec_\n\n                    act = exec_func(self.ui.rom_list.mapToGlobal(pos))\n\n                    if act == a_del:\n                        self.on_delete_selected()\n                    elif act == a_comp:\n                        self.tools_controller.on_compress_selected()\n                    elif act == a_recomp:\n                        self.tools_controller.on_recompress_selected()\n                    elif act == a_decomp:\n                        self.tools_controller.on_decompress_selected()\n                    elif act == a_verify:\n                        self.on_verify_selected()\n                    elif act == a_identify:\n                        self.on_identify_selected()\n                    elif act == a_open:\n                        self._open_selected_rom_folder()\n                    elif act == a_copy:\n                        self._copy_selected_rom_path()\n                except Exception as e:\n                    self.log_msg(f\"Error showing context menu: {e}\")\n\n            self.ui.rom_list.customContextMenuRequested.connect(_show_menu)\n            self.log_msg(\"Context menu setup complete\")\n        except Exception as e:\n            self.log_msg(f\"Failed to setup context menu: {e}\")\n\n    def _setup_verification_context_menu(self):\n        \"\"\"Context menu for verification results to copy hashes or open location.\"\"\"\n        qt = self._qtwidgets\n        core = self._qtcore\n        try:\n            if not hasattr(self.ui, \"table_results\"):\n                return\n\n            Qt = core.Qt\n            policy = (\n                Qt.ContextMenuPolicy.CustomContextMenu\n                if hasattr(Qt, \"ContextMenuPolicy\")\n                else Qt.CustomContextMenu\n            )\n            self.ui.table_results.setContextMenuPolicy(policy)\n\n            def _show_menu(pos):\n                menu, actions = self._build_verification_menu(qt)\n                exec_func = menu.exec if hasattr(menu, \"exec\") else menu.exec_\n                act = exec_func(self.ui.table_results.mapToGlobal(pos))\n                row = self.ui.table_results.currentRow()\n                results = getattr(self, \"_last_verify_results\", [])\n                if 0 &lt;= row &lt; len(results):\n                    self._handle_verification_action(qt, act, actions, results[row])\n\n            self.ui.table_results.customContextMenuRequested.connect(_show_menu)\n        except Exception:\n            pass\n\n    def _build_verification_menu(self, qt):\n        menu = qt.QMenu(self.ui.table_results)\n        a_open = menu.addAction(\"Open Location\")\n        menu.addSeparator()\n        a_crc = menu.addAction(\"Copy CRC32\")\n        a_sha1 = menu.addAction(\"Copy SHA1\")\n        a_md5 = menu.addAction(\"Copy MD5\")\n        a_sha256 = menu.addAction(\"Copy SHA256\")\n        actions = {\n            \"open\": a_open,\n            \"crc\": a_crc,\n            \"sha1\": a_sha1,\n            \"md5\": a_md5,\n            \"sha256\": a_sha256,\n        }\n        return menu, actions\n\n    def _handle_verification_action(self, qt, act, actions, res):\n        try:\n            if act == actions[\"open\"]:\n                fp = getattr(res, \"full_path\", None)\n                if fp:\n                    self._open_file_location(Path(fp))\n            elif act == actions[\"crc\"]:\n                qt.QApplication.clipboard().setText(res.crc or \"\")\n                self.status.showMessage(\"CRC32 copied\", 2000)\n            elif act == actions[\"sha1\"]:\n                qt.QApplication.clipboard().setText(res.sha1 or \"\")\n                self.status.showMessage(\"SHA1 copied\", 2000)\n            elif act == actions[\"md5\"]:\n                qt.QApplication.clipboard().setText(getattr(res, \"md5\", \"\") or \"\")\n                self.status.showMessage(\"MD5 copied\", 2000)\n            elif act == actions[\"sha256\"]:\n                qt.QApplication.clipboard().setText(getattr(res, \"sha256\", \"\") or \"\")\n                self.status.showMessage(\"SHA256 copied\", 2000)\n        except Exception:\n            pass\n\n    def _open_selected_rom_folder(self):\n        try:\n            sel = self.ui.rom_list.currentItem()\n            sys_item = self.ui.sys_list.currentItem()\n            if not sel or not sys_item:\n                return\n            p = Path(self._last_base) / \"roms\" / sys_item.text() / sel.text()\n            self._open_file_location(p)\n        except Exception:\n            pass\n\n    def _copy_selected_rom_path(self):\n        try:\n            qt = self._qtwidgets\n            sel = self.ui.rom_list.currentItem()\n            sys_item = self.ui.sys_list.currentItem()\n            if not sel or not sys_item:\n                return\n            p = Path(self._last_base) / \"roms\" / sys_item.text() / sel.text()\n            cb = qt.QApplication.clipboard()\n            cb.setText(str(p))\n            self.status.showMessage(\"Path copied to clipboard\", 3000)\n        except Exception:\n            pass\n\n    def _open_file_location(self, path: Path):\n        try:\n            import subprocess\n\n            if path.is_dir():\n                subprocess.run([\"xdg-open\", str(path)], check=False)\n            else:\n                subprocess.run([\"xdg-open\", str(path.parent)], check=False)\n        except Exception:\n            self.log_msg(f\"Failed to open location: {path}\")\n\n    # Background/task helpers\n    def _run_in_background(\n        self,\n        func: Callable[[], object],\n        done_cb: Optional[Callable[[object], None]] = None,\n    ):\n        \"\"\"Run func() in a thread and call done_cb(result) in the GUI thread.\"\"\"\n        self._cancel_event.clear()\n        future = self._submit_task(func)\n        self._active_future = future\n\n        if self._qtcore:\n            self._start_polling_timer(future, done_cb)\n\n        self._enable_cancel_button()\n        return future\n\n    def _submit_task(self, func: Callable[[], object]):\n        if self._executor:\n            return self._executor.submit(func)\n\n        # Synchronous fallback\n        class _F:\n            def __init__(self, res):\n                self._res = res\n\n            def done(self):\n                return True\n\n            def result(self):\n                return self._res\n\n        try:\n            res = func()\n        except Exception as e:\n            res = e\n        return _F(res)\n\n    def _start_polling_timer(self, future, done_cb):\n        timer = self._qtcore.QTimer(self.window)\n        timer.setInterval(200)\n\n        def _check():\n            if not future.done():\n                return\n            timer.stop()\n            try:\n                result = future.result()\n            except Exception as e:\n                result = e\n\n            if done_cb:\n                try:\n                    done_cb(result)\n                except Exception as e:\n                    self.log_msg(f\"Background callback error: {e}\")\n                    if hasattr(self, \"logger\"):\n                        self.logger.exception(\"Background callback error\")\n\n        timer.timeout.connect(_check)\n        timer.start()\n        self._active_timer = timer\n\n    def _enable_cancel_button(self):\n        try:\n            if hasattr(self.ui, \"btn_cancel\") and self.ui.btn_cancel:\n                self.ui.btn_cancel.setEnabled(True)\n        except Exception:\n            pass\n\n    def _load_settings(self):\n        if not self._settings:\n            return\n        try:\n            self._restore_window_settings()\n            self._restore_ui_settings()\n        except Exception:\n            pass\n\n    def _save_settings(self):\n        if not self._settings:\n            return\n        try:\n            self._persist_window_settings()\n            self._persist_ui_settings()\n        except Exception:\n            pass\n\n    def _restore_window_settings(self):\n        \"\"\"Restore geometry/state and base dir from QSettings.\"\"\"\n        try:\n            # Geometry/state\n            try:\n                geom = self._settings.value(\"ui/window_geometry\")\n                if geom:\n                    self.window.restoreGeometry(geom)\n            except Exception:\n                # legacy width/height\n                w = self._settings.value(\"window/width\")\n                h = self._settings.value(\"window/height\")\n                if w and h:\n                    try:\n                        self.window.resize(int(w), int(h))\n                    except Exception:\n                        pass\n            try:\n                st = self._settings.value(\"ui/window_state\")\n                if st:\n                    self.window.restoreState(st)\n            except Exception:\n                pass\n            # Last base\n            last = self._settings.value(\"last_base\")\n            if last:\n                path = Path(str(last))\n                if path.exists():\n                    self._last_base = path\n                    try:\n                        self.ui.lbl_library.setText(str(self._last_base))\n                        self.ui.lbl_library.setStyleSheet(\n                            \"font-weight: bold; color: #3daee9;\"\n                        )\n                        # Enable UI since we have a library\n                        self._set_ui_enabled(True)\n                        self.log_msg(f\"Restored last library: {self._last_base}\")\n\n                        # Update logger to write to the new library's log folder\n                        self._update_logger(self._last_base)\n                    except Exception:\n                        pass\n                else:\n                    self.log_msg(f\"Last library path not found: {path}\")\n        except Exception:\n            pass\n\n    def _restore_ui_settings(self):\n        \"\"\"Restore checkboxes, toolbar visibility, filters, splitter, and widths.\"\"\"\n        try:\n            self._restore_checkboxes()\n            self._restore_extras()\n            self._restore_splitter()\n            self._restore_toolbar_visibility()\n            self._restore_table_widths()\n            self._restore_last_system()\n        except Exception:\n            pass\n\n    def _restore_checkboxes(self):\n        try:\n            self.chk_dry_run.setChecked(\n                str(self._settings.value(\"settings/dry_run\", \"false\")).lower() == \"true\"\n            )\n            self.spin_level.setValue(int(self._settings.value(\"settings/level\", 3)))\n            self.combo_profile.setCurrentText(\n                str(self._settings.value(\"settings/profile\", \"None\"))\n            )\n            self.chk_rm_originals.setChecked(\n                str(self._settings.value(\"settings/rm_originals\", \"false\")).lower()\n                == \"true\"\n            )\n            self.chk_quarantine.setChecked(\n                str(self._settings.value(\"settings/quarantine\", \"false\")).lower()\n                == \"true\"\n            )\n            self.chk_deep_verify.setChecked(\n                str(self._settings.value(\"settings/deep_verify\", \"false\")).lower()\n                == \"true\"\n            )\n            self.chk_recursive.setChecked(\n                str(self._settings.value(\"settings/recursive\", \"true\")).lower()\n                == \"true\"\n            )\n            self.chk_process_selected.setChecked(\n                str(self._settings.value(\"settings/process_selected\", \"false\")).lower()\n                == \"true\"\n            )\n            self.chk_standardize_names.setChecked(\n                str(self._settings.value(\"settings/standardize_names\", \"false\")).lower()\n                == \"true\"\n            )\n        except Exception:\n            pass\n\n    def _restore_extras(self):\n        try:\n            vis = str(self._settings.value(\"ui/log_visible\", \"true\")).lower() == \"true\"\n            self.ui.log_dock.setVisible(vis)\n        except Exception:\n            pass\n        try:\n            if hasattr(self.ui, \"edit_filter\"):\n                self.ui.edit_filter.setText(\n                    str(self._settings.value(\"ui/rom_filter\", \"\"))\n                )\n            if hasattr(self.ui, \"combo_verif_filter\"):\n                idx = int(self._settings.value(\"ui/verif_filter_idx\", 0))\n                self.ui.combo_verif_filter.setCurrentIndex(idx)\n        except Exception:\n            pass\n\n    def _restore_splitter(self):\n        try:\n            st = self._settings.value(\"ui/splitter_state\")\n            if st:\n                self.ui.splitter.restoreState(st)\n        except Exception:\n            pass\n\n    def _restore_toolbar_visibility(self):\n        try:\n            tb_vis = (\n                str(self._settings.value(\"ui/toolbar_visible\", \"true\")).lower()\n                == \"true\"\n            )\n            if hasattr(self, \"_toolbar\") and self._toolbar:\n                self._toolbar.setVisible(tb_vis)\n            if hasattr(self, \"act_toggle_toolbar\"):\n                self.act_toggle_toolbar.setChecked(tb_vis)\n        except Exception:\n            pass\n\n    def _restore_table_widths(self):\n        try:\n            widths = self._settings.value(\"ui/verif_table_widths\")\n            if widths and hasattr(self.ui, \"table_results\"):\n                if isinstance(widths, (list, tuple)):\n                    for i, w in enumerate(widths):\n                        try:\n                            self.ui.table_results.setColumnWidth(i, int(w))\n                        except Exception:\n                            pass\n        except Exception:\n            pass\n\n    def _restore_last_system(self):\n        try:\n            self._last_system = (\n                str(self._settings.value(LAST_SYSTEM_KEY))\n                if self._settings.value(LAST_SYSTEM_KEY)\n                else None\n            )\n        except Exception:\n            self._last_system = None\n\n    def _persist_window_settings(self):\n        \"\"\"Persist geometry/state and base dir to QSettings.\"\"\"\n        try:\n            # Geometry/state\n            try:\n                self._settings.setValue(\n                    \"ui/window_geometry\", self.window.saveGeometry()\n                )\n                self._settings.setValue(\"ui/window_state\", self.window.saveState())\n            except Exception:\n                # legacy\n                self._settings.setValue(\"window/width\", self.window.width())\n                self._settings.setValue(\"window/height\", self.window.height())\n            if self._last_base:\n                self._settings.setValue(\"last_base\", str(self._last_base))\n        except Exception:\n            pass\n\n    def _persist_ui_settings(self):\n        \"\"\"Persist checkboxes, filters, splitter, toolbar visibility, and widths.\"\"\"\n        try:\n            self._persist_checkbox_settings()\n            self._persist_extras()\n            self._persist_splitter()\n            self._persist_table_widths()\n        except Exception:\n            pass\n\n    def _persist_checkbox_settings(self):\n        try:\n            self._settings.setValue(\n                \"settings/dry_run\", str(self.chk_dry_run.isChecked())\n            )\n            self._settings.setValue(\"settings/level\", self.spin_level.value())\n            self._settings.setValue(\n                \"settings/profile\", self.combo_profile.currentText()\n            )\n            self._settings.setValue(\n                \"settings/rm_originals\", str(self.chk_rm_originals.isChecked())\n            )\n            self._settings.setValue(\n                \"settings/quarantine\", str(self.chk_quarantine.isChecked())\n            )\n            self._settings.setValue(\n                \"settings/deep_verify\", str(self.chk_deep_verify.isChecked())\n            )\n            self._settings.setValue(\n                \"settings/recursive\", str(self.chk_recursive.isChecked())\n            )\n            self._settings.setValue(\n                \"settings/process_selected\",\n                str(self.chk_process_selected.isChecked()),\n            )\n            self._settings.setValue(\n                \"settings/standardize_names\",\n                str(self.chk_standardize_names.isChecked()),\n            )\n        except Exception:\n            pass\n\n    def _persist_extras(self):\n        try:\n            self._settings.setValue(\"ui/log_visible\", str(self.ui.log_dock.isVisible()))\n            if hasattr(self.ui, \"edit_filter\"):\n                self._settings.setValue(\"ui/rom_filter\", self.ui.edit_filter.text())\n            if hasattr(self.ui, \"combo_verif_filter\"):\n                self._settings.setValue(\n                    \"ui/verif_filter_idx\",\n                    self.ui.combo_verif_filter.currentIndex(),\n                )\n        except Exception:\n            pass\n\n    def _persist_splitter(self):\n        try:\n            self._settings.setValue(\"ui/splitter_state\", self.ui.splitter.saveState())\n        except Exception:\n            pass\n\n    def _persist_table_widths(self):\n        try:\n            if hasattr(self.ui, \"table_results\"):\n                widths = [\n                    self.ui.table_results.columnWidth(i)\n                    for i in range(self.ui.table_results.columnCount())\n                ]\n                self._settings.setValue(\"ui/verif_table_widths\", widths)\n        except Exception:\n            pass\n\n    def _on_close_event(self, event):\n        self.log_msg(\"Shutting down...\")\n        self._cancel_event.set()\n        # Persist settings before closing\n        try:\n            self._save_settings()\n        except Exception:\n            pass\n        if self._executor:\n            self._executor.shutdown(wait=False)\n        if self._original_close_event:\n            self._original_close_event(event)\n        else:\n            event.accept()\n\n    def _set_ui_enabled(self, enabled: bool):\n        try:\n            self.ui.btn_init.setEnabled(enabled)\n            self.ui.btn_list.setEnabled(enabled)\n            self.ui.btn_add.setEnabled(enabled)\n            self.ui.btn_clear.setEnabled(enabled)\n            self.ui.btn_open_lib.setEnabled(enabled)\n\n            # Also disable/enable tool buttons\n            self.ui.btn_organize.setEnabled(enabled)\n            self.ui.btn_health.setEnabled(enabled)\n            self.ui.btn_switch_compress.setEnabled(enabled)\n            self.ui.btn_switch_decompress.setEnabled(enabled)\n            self.ui.btn_ps2_convert.setEnabled(enabled)\n            self.ui.btn_ps2_verify.setEnabled(enabled)\n            self.ui.btn_ps2_organize.setEnabled(enabled)\n            self.ui.btn_ps3_verify.setEnabled(enabled)\n            self.ui.btn_ps3_organize.setEnabled(enabled)\n            self.ui.btn_psp_verify.setEnabled(enabled)\n            self.ui.btn_psp_organize.setEnabled(enabled)\n            self.ui.btn_dolphin_convert.setEnabled(enabled)\n            self.ui.btn_dolphin_verify.setEnabled(enabled)\n            self.ui.btn_clean_junk.setEnabled(enabled)\n\n            # Verification Tab\n            self.ui.btn_select_dat.setEnabled(enabled)\n\n            # Verify DAT button logic\n            # It should be enabled if we have a DAT selected OR a library open\n            # (for auto-discovery)\n            has_dat = bool(getattr(self, \"_current_dat_path\", None))\n            has_base = bool(getattr(self, \"_last_base\", None))\n            can_verify = enabled and (has_dat or has_base)\n\n            # print(f\"DEBUG: enabled={enabled} has_dat={has_dat} ...\")\n            self.ui.btn_verify_dat.setEnabled(can_verify)\n\n            # Identify All button logic\n            if hasattr(self.ui, \"btn_identify_all\"):\n                self.ui.btn_identify_all.setEnabled(enabled and bool(self._last_base))\n\n            # Compression buttons\n            self.ui.btn_compress.setEnabled(enabled)\n            self.ui.btn_recompress.setEnabled(enabled)\n            self.ui.btn_decompress.setEnabled(enabled)\n\n            # Cancel button logic is inverse\n            self.ui.btn_cancel.setEnabled(not enabled)\n\n            # Show/Hide progress bar\n            self.ui.progress_bar.setVisible(not enabled)\n            if enabled:\n                self.ui.progress_bar.setValue(0)\n                self.status.clearMessage()\n        except Exception:\n            pass\n\n    def progress_hook(self, percent: float, message: str):\n        \"\"\"Simple progress hook for compression helpers.\n\n        percent: 0.0 to 1.0\n\n        Updates the status bar and appends a short log message. Safe to be set\n        as `args.progress_callback` in `switch_organizer`.\n        \"\"\"\n        if self._signaler:\n            self._signaler.progress_signal.emit(percent, message)\n        else:\n            self._progress_slot(percent, message)\n\n    # The following methods interact with manager; keep them small and testable\n    def on_init(self):\n        qt = self._qtwidgets\n        base = self._last_base\n        if not base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        try:\n            yes_btn = qt.QMessageBox.StandardButton.Yes\n            no_btn = qt.QMessageBox.StandardButton.No\n        except AttributeError:\n            yes_btn = qt.QMessageBox.Yes\n            no_btn = qt.QMessageBox.No\n\n        dry = qt.QMessageBox.question(\n            self.window,\n            \"Dry-run?\",\n            \"Run in dry-run (no changes)?\",\n            yes_btn | no_btn,\n        )\n        dry_run = dry == yes_btn\n        self.log_msg(f\"Running init on: {base} (dry={dry_run})\")\n\n        def _work():\n            return self._manager.cmd_init(base, dry_run=dry_run)\n\n        def _done(result):\n            if isinstance(result, Exception):\n                self.log_msg(f\"Init error: {result}\")\n            else:\n                try:\n                    self.log_msg(f\"Finished init, rc={result}\")\n                except Exception:\n                    pass\n            self._set_ui_enabled(True)\n\n        self._set_ui_enabled(False)\n        self._run_in_background(_work, _done)\n\n    def on_list(self):\n        base = self._last_base\n        if not base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        # Ensure UI is enabled before listing\n        self._set_ui_enabled(True)\n\n        systems = self._manager.cmd_list_systems(base)\n        self._refresh_system_list_ui(systems)\n        self._log_systems(systems)\n        self._update_dashboard_stats(systems)\n\n    def _update_dashboard_stats(self, systems=None):\n        try:\n            if systems is None:\n                if self._last_base:\n                    systems = self._manager.cmd_list_systems(self._last_base)\n                else:\n                    systems = []\n\n            if hasattr(self.ui, \"lbl_systems_count\"):\n                self.ui.lbl_systems_count.setText(f\"Systems Configured: {len(systems)}\")\n\n            # Calculate total files (approximate)\n            total_files = 0\n            roms_root = self._manager.get_roms_dir(self._last_base)\n            for sys_name in systems:\n                try:\n                    p = roms_root / sys_name\n                    # Count files recursively\n                    total_files += sum(1 for _ in p.rglob(\"*\") if _.is_file())\n                except Exception:\n                    logging.warning(\n                        f\"Failed to count files for {sys_name}\", exc_info=True\n                    )\n\n            if hasattr(self.ui, \"lbl_total_roms\"):\n                self.ui.lbl_total_roms.setText(f\"Total Files: {total_files}\")\n        except Exception:\n            logging.error(\"Failed to update dashboard stats\", exc_info=True)\n\n    def _refresh_system_list_ui(self, systems):\n        try:\n            if self.sys_list is not None:\n                self.sys_list.clear()\n                for s in systems:\n                    self.sys_list.addItem(s)\n                self._auto_select_last_system()\n\n            # Update Gallery Combo\n            if hasattr(self.ui, \"combo_gallery_system\"):\n                self.ui.combo_gallery_system.clear()\n                self.ui.combo_gallery_system.addItems(systems)\n        except Exception:\n            pass\n\n    def _auto_select_last_system(self):\n        try:\n            if getattr(self, \"_last_system\", None):\n                items = [\n                    self.sys_list.item(i).text() for i in range(self.sys_list.count())\n                ]\n                if self._last_system in items:\n                    idx = items.index(self._last_system)\n                    self.sys_list.setCurrentRow(idx)\n                    self._on_system_selected(self.sys_list.item(idx))\n        except Exception:\n            pass\n\n    def _log_systems(self, systems):\n        if not systems:\n            self.log_msg(\"Nenhum sistema encontrado \u2014 execute 'init' primeiro.\")\n            return\n        self.log_msg(\"Sistemas encontrados:\")\n        for s in systems:\n            self.log_msg(f\" - {s}\")\n\n    def on_add(self):\n        base = self._last_base\n        if not base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        src = self._select_file_dialog(\"Select ROM file\")\n        if not src:\n            return\n\n        system = self._select_system_dialog(src, base)\n        if not system:\n            self.log_msg(\"Add ROM cancelled: No system selected.\")\n            return\n\n        move = self._ask_yes_no(\"Move file?\", \"Move file instead of copy?\")\n        dry_run = self._ask_yes_no(\"Dry-run?\", \"Run in dry-run (no changes)?\")\n\n        def _work_add():\n            return self._manager.cmd_add_rom(\n                src, base, system=system, move=move, dry_run=dry_run\n            )\n\n        def _done_add(result):\n            if isinstance(result, Exception):\n                self.log_msg(f\"Add ROM error: {result}\")\n            else:\n                try:\n                    self.log_msg(f\"Added ROM -&gt; {result}\")\n                    # Refresh list to show new file\n                    self.on_list()\n                    # Update dashboard stats\n                    self._update_dashboard_stats()\n                except Exception:\n                    pass\n            self._set_ui_enabled(True)\n\n        self._set_ui_enabled(False)\n        self._run_in_background(_work_add, _done_add)\n\n    def _select_file_dialog(self, title: str) -&gt; Optional[Path]:\n        qt = self._qtwidgets\n        # Use static method for better compatibility\n        fname, _ = qt.QFileDialog.getOpenFileName(self.window, title)\n        if fname:\n            return Path(fname)\n        return None\n\n    def _select_system_dialog(self, src: Path, base: Path) -&gt; Optional[str]:\n        qt = self._qtwidgets\n        guessed = self._manager.guess_system_for_file(src)\n        systems = self._manager.cmd_list_systems(base)\n\n        # If no systems found (empty library), populate with known systems\n        if not systems:\n            from emumanager.config import EXT_TO_SYSTEM\n\n            systems = sorted(list(set(EXT_TO_SYSTEM.values())))\n\n        items = sorted(systems)\n        idx = 0\n        if guessed:\n            if guessed not in items:\n                items.insert(0, guessed)\n            idx = items.index(guessed)\n\n        system, ok = qt.QInputDialog.getItem(\n            self.window, \"Select System\", \"Target System:\", items, idx, True\n        )\n        return system if ok and system else None\n\n    def _ask_yes_no(self, title: str, msg: str) -&gt; bool:\n        qt = self._qtwidgets\n        try:\n            yes_btn = qt.QMessageBox.StandardButton.Yes\n            no_btn = qt.QMessageBox.StandardButton.No\n        except AttributeError:\n            yes_btn = qt.QMessageBox.Yes\n            no_btn = qt.QMessageBox.No\n\n        ans = qt.QMessageBox.question(self.window, title, msg, yes_btn | no_btn)\n        return ans == yes_btn\n\n    # UI helpers for systems/rom listing\n    def _on_system_selected(self, item):\n        try:\n            system = item.text()\n            self._populate_roms(system)\n            # Remember last selected system\n            try:\n                if self._settings:\n                    self._settings.setValue(\"ui/last_system\", system)\n            except Exception:\n                pass\n\n            # Toggle Switch actions\n            if hasattr(self.ui, \"grp_switch_actions\"):\n                is_switch = system.lower() == \"switch\"\n                self.ui.grp_switch_actions.setVisible(is_switch)\n            # Apply current filter if present\n            if hasattr(self.ui, \"edit_filter\"):\n                self._apply_rom_filter(self.ui.edit_filter.text())\n        except Exception:\n            pass\n\n    def _on_rom_double_clicked(self, item):\n        try:\n            # double-click compresses by default\n            self.tools_controller.on_compress_selected()\n        except Exception:\n            pass\n\n    def _list_files_recursive(self, root: Path) -&gt; list[Path]:\n        \"\"\"List files recursively, excluding hidden files, DATs, and non-game files.\"\"\"\n        files = []\n        if not root.exists():\n            return files\n\n        # Extensions to ignore (junk, metadata, images, etc)\n        IGNORED_EXTENSIONS = {\n            \".dat\",\n            \".xml\",\n            \".txt\",\n            \".nfo\",\n            \".pdf\",\n            \".doc\",\n            \".docx\",\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".bmp\",\n            \".gif\",\n            \".ico\",\n            \".ini\",\n            \".cfg\",\n            \".conf\",\n            \".db\",\n            \".ds_store\",\n            \".url\",\n            \".lnk\",\n            \".desktop\",\n            \".py\",\n            \".pyc\",\n            \".log\",\n            \".err\",\n            \".out\",\n        }\n\n        for p in root.rglob(\"*\"):\n            if not p.is_file():\n                continue\n            if p.name.startswith(\".\"):\n                continue\n\n            if p.suffix.lower() in IGNORED_EXTENSIONS:\n                continue\n\n            try:\n                rel = p.relative_to(root)\n                if any(part.startswith(\".\") for part in rel.parts):\n                    continue\n\n                # Exclude dats/no-intro/redump folders\n                parts_lower = [part.lower() for part in rel.parts]\n                if (\n                    \"dats\" in parts_lower\n                    or \"no-intro\" in parts_lower\n                    or \"redump\" in parts_lower\n                ):\n                    continue\n\n                files.append(p)\n            except ValueError:\n                continue\n\n        files.sort(key=lambda p: str(p).lower())\n        return files\n\n    def _list_dirs_recursive(self, root: Path) -&gt; list[Path]:\n        \"\"\"List directories recursively, excluding hidden ones.\"\"\"\n        dirs = []\n        if not root.exists():\n            return dirs\n\n        for p in root.rglob(\"*\"):\n            if not p.is_dir():\n                continue\n            if p.name.startswith(\".\"):\n                continue\n\n            try:\n                rel = p.relative_to(root)\n                if any(part.startswith(\".\") for part in rel.parts):\n                    continue\n                dirs.append(p)\n            except ValueError:\n                continue\n\n        # Sort reverse to ensure we process children before parents\n        dirs.sort(key=lambda p: str(p), reverse=True)\n        return dirs\n\n    def _list_files_flat(self, root: Path) -&gt; list[Path]:\n        \"\"\"\n        List files in the directory (non-recursive), excluding hidden files and junk.\n        \"\"\"\n        files = []\n        if not root.exists():\n            return files\n\n        # Extensions to ignore (junk, metadata, images, etc)\n        IGNORED_EXTENSIONS = {\n            \".dat\",\n            \".xml\",\n            \".txt\",\n            \".nfo\",\n            \".pdf\",\n            \".doc\",\n            \".docx\",\n            \".jpg\",\n            \".jpeg\",\n            \".png\",\n            \".bmp\",\n            \".gif\",\n            \".ico\",\n            \".ini\",\n            \".cfg\",\n            \".conf\",\n            \".db\",\n            \".ds_store\",\n            \".url\",\n            \".lnk\",\n            \".desktop\",\n            \".py\",\n            \".pyc\",\n            \".log\",\n            \".err\",\n            \".out\",\n        }\n\n        for p in root.iterdir():\n            if not p.is_file():\n                continue\n            if p.name.startswith(\".\"):\n                continue\n\n            if p.suffix.lower() in IGNORED_EXTENSIONS:\n                continue\n\n            files.append(p)\n        return files\n\n    def _get_list_files_fn(self):\n        \"\"\"Returns the appropriate list_files function based on settings.\"\"\"\n        if self.chk_process_selected.isChecked():\n            return self._list_files_selected\n        elif self.chk_recursive.isChecked():\n            return self._list_files_recursive\n        else:\n            return self._list_files_flat\n\n    def _populate_roms(self, system: str):\n        if not self._last_base:\n            return\n        try:\n            # Use manager's logic to find roms dir\n            roms_root = self._manager.get_roms_dir(self._last_base)\n            roms_dir = roms_root / system\n\n            self.log_msg(f\"Listing ROMs for {system} in {roms_dir}\")\n\n            files = []\n            if roms_dir.exists():\n                # Always list recursively for the UI so users can see organized games\n                # regardless of the \"Recursive\" checkbox state\n                # (which controls processing).\n                full_files = self._list_files_recursive(roms_dir)\n                files = [p.relative_to(roms_dir) for p in full_files]\n                # Store for filtering\n                self._current_roms = [str(p) for p in files]\n                self.log_msg(f\"Found {len(files)} files.\")\n            else:\n                self.log_msg(f\"Directory not found: {roms_dir}\")\n\n            if self.rom_list is not None:\n                self.rom_list.clear()\n                for f in files:\n                    self.rom_list.addItem(str(f))\n        except Exception as e:\n            self.log_msg(f\"Error listing ROMs: {e}\")\n            if hasattr(self, \"logger\"):\n                self.logger.exception(\"Error listing ROMs\")\n\n    def _on_filter_text(self, text: str):\n        try:\n            self._apply_rom_filter(text)\n        except Exception:\n            pass\n\n    def _apply_rom_filter(self, text: str):\n        if not hasattr(self, \"_current_roms\"):\n            return\n        try:\n            query = (text or \"\").lower().strip()\n            items = self._current_roms\n            if query:\n                items = [s for s in items if query in s.lower()]\n            self.ui.rom_list.clear()\n            for s in items:\n                self.ui.rom_list.addItem(s)\n        except Exception:\n            pass\n\n    def on_cancel_requested(self):\n        try:\n            self._cancel_event.set()\n            from emumanager.common.execution import cancel_current_process\n\n            ok = cancel_current_process()\n            self.log_msg(\n                \"Cancel requested\" + (\" \u2014 cancelled\" if ok else \" \u2014 nothing to cancel\")\n            )\n        except Exception:\n            self.log_msg(\"Cancel requested \u2014 failed to call cancel\")\n\n    def _ensure_env(self, base_path: Path):\n        \"\"\"Ensure environment tools and paths are configured for the given base path.\"\"\"\n        if self._env and self._env.get(\"ROMS_DIR\") == base_path:\n            return\n\n        try:\n            from emumanager.common.execution import find_tool\n            from emumanager.switch.main_helpers import configure_environment\n\n            # Create a dummy args object for configure_environment\n            class Args:\n                dir = str(base_path)\n                keys = str(base_path / \"keys.txt\")  # Default assumption\n                compress = False\n                decompress = False\n\n            # We need to find keys.txt or ask user, but for now let's assume it's in\n            # base. If keys are not found, configure_environment might fail or warn.\n            # Let's try to find keys in common locations if not at base/keys.txt\n            keys_path = base_path / \"keys.txt\"\n            if not keys_path.exists():\n                keys_path = base_path / \"prod.keys\"\n\n            args = Args()\n            args.keys = str(keys_path)\n\n            # Mock logger to capture output to GUI log\n            class GuiLogger:\n                def info(_s, msg, *a):\n                    self.log_msg(msg % a if a else msg)\n\n                def warning(_s, msg, *a):\n                    self.log_msg(\"WARN: \" + (msg % a if a else msg))\n\n                def error(_s, msg, *a):\n                    self.log_msg(\"ERROR: \" + (msg % a if a else msg))\n\n                def debug(_s, msg, *a):\n                    pass  # ignore debug\n\n                def exception(_s, msg, *a):\n                    self.log_msg(\"EXCEPTION: \" + (msg % a if a else msg))\n\n            self._env = configure_environment(args, GuiLogger(), find_tool)\n            self.log_msg(f\"Environment configured for {base_path}\")\n        except Exception as e:\n            self.log_msg(f\"Failed to configure environment: {e}\")\n            self._env = {}\n\n    def _get_common_args(self):\n        class Args:\n            pass\n\n        args = Args()\n        args.dry_run = self.chk_dry_run.isChecked()\n        args.level = self.spin_level.value()\n        profile = self.combo_profile.currentText()\n        args.compression_profile = profile if profile != \"None\" else None\n        args.rm_originals = self.chk_rm_originals.isChecked()\n        args.quarantine = self.chk_quarantine.isChecked()\n        args.deep_verify = self.chk_deep_verify.isChecked()\n        args.clean_junk = False  # Handled separately\n        args.organize = False  # Handled separately\n        args.compress = False\n        args.decompress = False\n        args.recompress = False\n        args.keep_on_failure = False\n        args.cmd_timeout = None\n        args.quarantine_dir = None\n        args.report_csv = None\n        args.dup_check = \"fast\"\n        args.verbose = False\n        args.progress_callback = self.progress_hook\n        args.cancel_event = self._cancel_event\n        args.standardize_names = self.chk_standardize_names.isChecked()\n        return args\n\n    def on_open_library(self):\n        qt = self._qtwidgets\n        dlg = qt.QFileDialog(self.window, \"Select Library Directory\")\n        try:\n            dlg.setFileMode(qt.QFileDialog.FileMode.Directory)\n        except AttributeError:\n            dlg.setFileMode(qt.QFileDialog.Directory)\n\n        if dlg.exec():\n            base = Path(dlg.selectedFiles()[0])\n            self._last_base = base\n            self.ui.lbl_library.setText(str(base))\n            self.ui.lbl_library.setStyleSheet(\"font-weight: bold; color: #3daee9;\")\n\n            # Update logger to write to the new library's log folder\n            self._update_logger(base)\n\n            self.log_msg(f\"Library opened: {base}\")\n\n            # Enable verification button (auto-discovery possible)\n            self.ui.btn_verify_dat.setEnabled(True)\n            if hasattr(self.ui, \"btn_identify_all\"):\n                self.ui.btn_identify_all.setEnabled(True)\n\n            # Auto-refresh list if possible\n            try:\n                self.on_list()\n            except Exception:\n                pass\n\n    def on_select_dat(self):\n        qt = self._qtwidgets\n        dlg = qt.QFileDialog(self.window, \"Select DAT File\")\n        try:\n            dlg.setFileMode(qt.QFileDialog.FileMode.ExistingFile)\n        except AttributeError:\n            dlg.setFileMode(qt.QFileDialog.ExistingFile)\n        dlg.setNameFilter(\"DAT Files (*.dat *.xml)\")\n\n        if dlg.exec():\n            path = Path(dlg.selectedFiles()[0])\n            self._current_dat_path = path\n            self.ui.lbl_dat_path.setText(path.name)\n            self.ui.lbl_dat_path.setStyleSheet(\"color: #3daee9; font-weight: bold;\")\n            self.ui.btn_verify_dat.setEnabled(True)\n            self.log_msg(f\"Selected DAT: {path}\")\n\n    def on_verify_dat(self):\n        if not self._last_base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        # Determine target path (System specific if selected)\n        target_path = self._last_base\n        selected_items = self.ui.sys_list.selectedItems()\n        if selected_items:\n            system_name = selected_items[0].text()\n            # Try to resolve system path\n            p1 = self._last_base / system_name\n            p2 = self._last_base / \"roms\" / system_name\n\n            if p1.exists():\n                target_path = p1\n                self.log_msg(f\"Targeting system folder: {system_name}\")\n            elif p2.exists():\n                target_path = p2\n                self.log_msg(f\"Targeting system folder: {system_name}\")\n\n        # If no DAT selected, prompt user\n        if not getattr(self, \"_current_dat_path\", None):\n            self.on_select_dat()\n            # If still no DAT, return (user cancelled)\n            if not getattr(self, \"_current_dat_path\", None):\n                return\n\n        dat_path = self._current_dat_path\n\n        args = self._get_common_args()\n        args.dat_path = dat_path\n\n        # Try to locate 'dats' folder in common locations\n        candidates = [\n            self._last_base / \"dats\",\n            self._last_base.parent / \"dats\",\n            self._last_base.parent.parent / \"dats\",\n        ]\n        args.dats_root = next((p for p in candidates if p.exists()), None)\n\n        # Clear previous results\n        self.ui.table_results.setRowCount(0)\n\n        def _work():\n            return worker_hash_verify(\n                target_path, args, self.log_msg, self._get_list_files_fn()\n            )\n\n        def _done(res):\n            if hasattr(res, \"results\"):\n                self.log_msg(res.text)\n                # Store for filtering/export\n                self._last_verify_results = res.results\n                self.on_verification_filter_changed()\n            else:\n                self.log_msg(str(res))\n            self._set_ui_enabled(True)\n\n        self._set_ui_enabled(False)\n        self._run_in_background(_work, _done)\n\n    def _populate_verification_results(\n        self, results, status_filter: Optional[str] = None\n    ):\n        filtered = [\n            r for r in results if (not status_filter or r.status == status_filter)\n        ]\n        self.ui.table_results.setRowCount(len(filtered))\n        for i, r in enumerate(filtered):\n            self._create_result_row(i, r)\n\n    def _create_result_row(self, row_idx, result):\n        qt = self._qtwidgets\n\n        # Status Item with Color\n        item_status = qt.QTableWidgetItem(result.status)\n        self._style_status_item(item_status, result.status)\n        self.ui.table_results.setItem(row_idx, 0, item_status)\n\n        # Other columns\n        self.ui.table_results.setItem(row_idx, 1, qt.QTableWidgetItem(result.filename))\n        self.ui.table_results.setItem(\n            row_idx, 2, qt.QTableWidgetItem(result.match_name or \"\")\n        )\n        self.ui.table_results.setItem(\n            row_idx, 3, qt.QTableWidgetItem(result.dat_name or \"\")\n        )\n        self.ui.table_results.setItem(row_idx, 4, qt.QTableWidgetItem(result.crc or \"\"))\n        self.ui.table_results.setItem(\n            row_idx, 5, qt.QTableWidgetItem(result.sha1 or \"\")\n        )\n        # New columns: MD5 and SHA256 (if deep verify)\n        try:\n            self.ui.table_results.setItem(\n                row_idx,\n                6,\n                qt.QTableWidgetItem(getattr(result, \"md5\", \"\") or \"\"),\n            )\n            self.ui.table_results.setItem(\n                row_idx,\n                7,\n                qt.QTableWidgetItem(getattr(result, \"sha256\", \"\") or \"\"),\n            )\n        except Exception:\n            pass\n\n    def _style_status_item(self, item, status):\n        qt = self._qtwidgets\n        if status == \"VERIFIED\":\n            bg_color = (\n                self._qtgui.QColor(200, 255, 200)\n                if self._qtgui\n                else qt.QColor(0, 255, 0)\n            )\n            fg_color = (\n                self._qtgui.QColor(0, 100, 0) if self._qtgui else qt.QColor(0, 0, 0)\n            )\n        else:\n            bg_color = (\n                self._qtgui.QColor(255, 200, 200)\n                if self._qtgui\n                else qt.QColor(255, 0, 0)\n            )\n            fg_color = (\n                self._qtgui.QColor(100, 0, 0) if self._qtgui else qt.QColor(0, 0, 0)\n            )\n\n        item.setBackground(bg_color)\n        item.setForeground(fg_color)\n\n    def _on_verification_item_dblclick(self, item):\n        try:\n            row = item.row()\n            results = getattr(self, \"_last_verify_results\", [])\n            if 0 &lt;= row &lt; len(results):\n                fp = results[row].full_path\n                if fp:\n                    self._open_file_location(Path(fp))\n        except Exception:\n            pass\n\n    def on_verification_filter_changed(self):\n        status = None\n        if hasattr(self.ui, \"combo_verif_filter\"):\n            txt = self.ui.combo_verif_filter.currentText()\n            if txt in (\"VERIFIED\", \"UNKNOWN\"):\n                status = txt\n        results = getattr(self, \"_last_verify_results\", [])\n        self._populate_verification_results(results, status)\n\n    def on_export_verification_csv(self):\n        qt = self._qtwidgets\n        results = self._get_filtered_verification_results()\n        if not results:\n            self.log_msg(\"No results to export.\")\n            return\n        path = self._ask_export_path(qt) or str(\n            (self._last_base or Path(\".\")) / \"verification_results.csv\"\n        )\n        self._write_verification_csv(path, results)\n\n    def _get_filtered_verification_results(self):\n        all_results = getattr(self, \"_last_verify_results\", [])\n        status = None\n        if hasattr(self.ui, \"combo_verif_filter\"):\n            txt = self.ui.combo_verif_filter.currentText()\n            if txt in (\"VERIFIED\", \"UNKNOWN\"):\n                status = txt\n        return [r for r in all_results if (not status or r.status == status)]\n\n    def _ask_export_path(self, qt):\n        try:\n            dlg = qt.QFileDialog(self.window, \"Export Verification CSV\")\n            try:\n                dlg.setAcceptMode(qt.QFileDialog.AcceptMode.AcceptSave)\n            except AttributeError:\n                dlg.setAcceptMode(qt.QFileDialog.AcceptSave)\n            dlg.setNameFilter(\"CSV Files (*.csv)\")\n            if dlg.exec():\n                return dlg.selectedFiles()[0]\n        except Exception:\n            pass\n        return None\n\n    def _write_verification_csv(self, path, results):\n        try:\n            import csv\n\n            with open(path, \"w\", newline=\"\") as f:\n                w = csv.writer(f)\n                w.writerow(\n                    [\n                        \"Status\",\n                        \"File Name\",\n                        \"Game Name\",\n                        \"CRC32\",\n                        \"SHA1\",\n                        \"MD5\",\n                        \"SHA256\",\n                    ]\n                )\n                for r in results:\n                    w.writerow(\n                        [\n                            r.status,\n                            r.filename,\n                            r.match_name or \"\",\n                            r.crc or \"\",\n                            r.sha1 or \"\",\n                            getattr(r, \"md5\", \"\") or \"\",\n                            getattr(r, \"sha256\", \"\") or \"\",\n                        ]\n                    )\n            self.log_msg(f\"Exported CSV: {path}\")\n        except Exception as e:\n            self.log_msg(f\"Export CSV error: {e}\")\n\n    def _list_files_selected(self, root: Path) -&gt; list[Path]:\n        \"\"\"Return only selected files from the UI, resolved to absolute paths.\"\"\"\n        if not self.rom_list or not self.sys_list:\n            return []\n\n        selected_items = self.rom_list.selectedItems()\n        if not selected_items:\n            return []\n\n        sys_item = self.sys_list.currentItem()\n        if not sys_item:\n            return []\n\n        system = sys_item.text()\n        roms_dir = Path(self._last_base) / \"roms\" / system\n\n        files = []\n        for item in selected_items:\n            rel_path = item.text()\n            full_path = roms_dir / rel_path\n            # Only include if it exists (sanity check)\n            if full_path.exists():\n                files.append(full_path)\n\n        return files\n\n    def on_organize_all(self):\n        \"\"\"Organize all supported systems sequentially.\"\"\"\n        if not self._last_base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        self._ensure_env(self._last_base)\n        args = self._get_common_args()\n        args.organize = True\n\n        self.log_msg(\"Starting batch organization...\")\n\n        def _work():\n            results = []\n\n            # 1. Distribute root files\n            # If _last_base is the 'roms' folder, we scan it directly.\n            # If _last_base is the project root, we might need to append 'roms'.\n            # Based on user log, _last_base seems to be the roms folder.\n            # But let's be safe: check if 'roms' subdir exists.\n\n            target_root = self._last_base\n            if (self._last_base / \"roms\").exists():\n                target_root = self._last_base / \"roms\"\n\n            self.log_msg(f\"Distributing files in {target_root}...\")\n            dist_stats = worker_distribute_root(\n                target_root,\n                self.log_msg,\n                progress_cb=getattr(self, \"progress_hook\", None),\n                cancel_event=self._cancel_event,\n            )\n            results.append(f\"Distribution: {dist_stats}\")\n\n            # 2. Run Switch Organizer\n            # We want to organize the 'switch' folder inside target_root\n            switch_dir = target_root / \"switch\"\n            if switch_dir.exists():\n                self.log_msg(f\"Organizing Switch folder: {switch_dir}...\")\n\n                # Create a copy of env with updated ROMS_DIR\n                switch_env = self._env.copy()\n                switch_env[\"ROMS_DIR\"] = switch_dir\n                switch_env[\"CSV_FILE\"] = switch_dir / \"biblioteca_switch.csv\"\n                switch_env[\"DUPE_DIR\"] = switch_dir / \"_DUPLICATES\"\n\n                switch_res = worker_organize(\n                    switch_dir,\n                    switch_env,\n                    args,\n                    self.log_msg,\n                    self._list_files_flat,\n                    progress_cb=getattr(self, \"progress_hook\", None),\n                )\n                results.append(f\"Switch: {switch_res}\")\n            else:\n                results.append(\"Switch: Skipped (folder not found)\")\n\n            return \"\\n\".join(results)\n\n        def _done(res):\n            if isinstance(res, Exception):\n                self.log_msg(f\"Batch Organization error: {res}\")\n            else:\n                self.log_msg(str(res))\n            self._set_ui_enabled(True)\n            self._update_dashboard_stats()\n\n        self._set_ui_enabled(False)\n        self._run_in_background(_work, _done)\n\n    def on_verify_all(self):\n        \"\"\"Verify all supported systems sequentially.\"\"\"\n        if not self._last_base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n        self.log_msg(\n            \"Starting batch verification (Not implemented yet for all systems)\"\n        )\n        # Placeholder\n        self.tools_controller.on_health_check()\n\n    def on_delete_selected(self):\n        if not self.rom_list:\n            return\n        try:\n            sel_items = self.rom_list.selectedItems()\n            if not sel_items:\n                self.log_msg(MSG_NO_ROM)\n                return\n\n            sys_item = self.sys_list.currentItem() if self.sys_list else None\n            if not sys_item:\n                self.log_msg(MSG_NO_SYSTEM)\n                return\n            system = sys_item.text()\n            roms_root = self._manager.get_roms_dir(self._last_base)\n\n            files_to_delete = []\n            for item in sel_items:\n                filepath = roms_root / system / item.text()\n                if filepath.exists():\n                    files_to_delete.append(filepath)\n\n            if not files_to_delete:\n                return\n\n            msg = f\"Are you sure you want to delete {len(files_to_delete)} files?\"\n            if not self._ask_yes_no(\"Confirm Delete\", msg):\n                return\n\n            count = 0\n            for fp in files_to_delete:\n                try:\n                    fp.unlink()\n                    count += 1\n                    self.log_msg(f\"Deleted: {fp.name}\")\n                except Exception as e:\n                    self.log_msg(f\"Failed to delete {fp.name}: {e}\")\n\n            if count &gt; 0:\n                self._populate_roms(system)\n                self._update_dashboard_stats()\n\n        except Exception as e:\n            self.log_msg(f\"Error deleting files: {e}\")\n\n    def on_verify_selected(self):\n        if not self.rom_list:\n            return\n        try:\n            sel = self.rom_list.currentItem()\n            if sel is None:\n                self.log_msg(MSG_NO_ROM)\n                return\n            rom_name = sel.text()\n            sys_item = self.sys_list.currentItem() if self.sys_list else None\n            if not sys_item:\n                self.log_msg(MSG_NO_SYSTEM)\n                return\n            system = sys_item.text()\n            roms_root = self._manager.get_roms_dir(self._last_base)\n            filepath = roms_root / system / rom_name\n\n            if not filepath.exists():\n                self.log_msg(f\"File not found: {filepath}\")\n                return\n\n            self.log_msg(f\"Calculating hashes for {rom_name}...\")\n\n            def _work():\n                return calculate_hashes(filepath)\n\n            def _done(res):\n                if not res:\n                    self.log_msg(f\"Failed to calculate hashes for {rom_name}\")\n                else:\n                    self.log_msg(f\"Hashes for {rom_name}:\")\n                    for algo, val in res.items():\n                        self.log_msg(f\"  {algo.upper()}: {val}\")\n                self._set_ui_enabled(True)\n\n            self._set_ui_enabled(False)\n            self._run_in_background(_work, _done)\n\n        except Exception as e:\n            self.log_msg(f\"Error verifying file: {e}\")\n\n    def _on_rom_selection_changed(self, current, previous):\n        if not current:\n            self.cover_label.clear()\n            self.cover_label.setText(\"No ROM selected\")\n            return\n\n        # Get system\n        if not self.sys_list.currentItem():\n            return\n        system = self.sys_list.currentItem().text()\n\n        # Get file path\n        if not self._last_base:\n            return\n\n        base_roms_dir = get_roms_dir(Path(self._last_base))\n        system_dir = base_roms_dir / system\n\n        rom_rel_path = current.text()\n        full_path = system_dir / rom_rel_path\n\n        # Start cover download/extraction\n        # Use a cache dir for covers\n        cache_dir = Path(self._last_base) / \".covers\"\n        cache_dir.mkdir(exist_ok=True)\n\n        self.log_msg(f\"Fetching cover for {rom_rel_path} (System: {system})...\")\n\n        # Guess region from filename\n        region = None\n        if \"(USA)\" in rom_rel_path or \"(US)\" in rom_rel_path:\n            region = \"US\"\n        elif \"(Europe)\" in rom_rel_path or \"(EU)\" in rom_rel_path:\n            region = \"EN\"\n        elif \"(Japan)\" in rom_rel_path or \"(JP)\" in rom_rel_path:\n            region = \"JA\"\n\n        downloader = CoverDownloader(\n            system, None, region, str(cache_dir), str(full_path)\n        )\n\n        # Force QueuedConnection to ensure UI updates happen in the main thread\n        conn_type = (\n            self._Qt_enum.ConnectionType.QueuedConnection\n            if self._Qt_enum and hasattr(self._Qt_enum, \"ConnectionType\")\n            else self._qtcore.Qt.QueuedConnection\n        )\n\n        downloader.signals.finished.connect(self._update_cover_image, conn_type)\n        downloader.signals.log.connect(self.log_msg, conn_type)\n\n        # Run in thread pool\n        if self._qtcore:\n            self._qtcore.QThreadPool.globalInstance().start(downloader)\n\n    def _update_cover_image(self, image_path):\n        import threading\n\n        self.log_msg(\n            f\"Update cover called in thread: {threading.current_thread().name}\"\n        )\n\n        if not image_path or not Path(image_path).exists():\n            self.cover_label.setText(\"No Cover Found\")\n            return\n\n        # Check file size\n        try:\n            size = Path(image_path).stat().st_size\n            if size == 0:\n                self.log_msg(f\"Error: Image file is empty: {image_path}\")\n                self.cover_label.setText(\"Empty Image\")\n                return\n        except Exception:\n            pass\n\n        self.log_msg(f\"Displaying cover: {image_path}\")\n        pixmap = self._qtgui.QPixmap(image_path)\n\n        if not pixmap.isNull():\n            self.log_msg(f\"Loaded pixmap: {pixmap.width()}x{pixmap.height()}\")\n            self.cover_label.setPixmap(pixmap)\n            self.cover_label.setVisible(True)\n        else:\n            self.log_msg(f\"Failed to load pixmap from {image_path}\")\n            self.cover_label.setText(\"Invalid Image\")\n\n    def on_identify_selected(self):\n        \"\"\"Identify the selected ROM using a DAT file.\"\"\"\n        if not self.rom_list:\n            return\n\n        sel = self.rom_list.currentItem()\n        if not sel:\n            self.log_msg(MSG_NO_ROM)\n            return\n\n        # Get file path\n        if not self._last_base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        system = (\n            self.sys_list.currentItem().text() if self.sys_list.currentItem() else \"\"\n        )\n        if not system:\n            self.log_msg(MSG_NO_SYSTEM)\n            return\n\n        base_roms_dir = get_roms_dir(Path(self._last_base))\n        rom_rel_path = sel.text()\n        full_path = base_roms_dir / system / rom_rel_path\n\n        if not full_path.exists():\n            self.log_msg(f\"File not found: {full_path}\")\n            return\n\n        # Try to auto-discover DAT first\n        from emumanager.verification.dat_manager import find_dat_for_system\n\n        dat_path = None\n\n        # Look in dats folder\n        dats_dir = self._last_base / \"dats\"\n        if dats_dir.exists():\n            found = find_dat_for_system(dats_dir, system)\n            if found:\n                dat_path = str(found)\n\n        # If not found, ask user\n        if not dat_path:\n            dat_path, _ = self._qtwidgets.QFileDialog.getOpenFileName(\n                self.window,\n                \"Select DAT File\",\n                str(self._last_base),\n                \"DAT Files (*.dat *.xml)\",\n            )\n\n        if not dat_path:\n            return\n\n        self.log_msg(f\"Identifying {full_path.name} using {Path(dat_path).name}...\")\n\n        def _work():\n            return worker_identify_single_file(\n                full_path, Path(dat_path), self.log_msg, self._progress_slot\n            )\n\n        def _done(res):\n            self.log_msg(str(res))\n            self._qtwidgets.QMessageBox.information(\n                self.window, \"Identification Result\", str(res)\n            )\n\n        self._run_in_background(_work, _done)\n\n    def on_identify_all(self):\n        if not self._last_base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        # Confirm with user as this is heavy\n        if not self._ask_yes_no(\n            \"Start Full Identification?\",\n            \"This will load ALL DAT files into memory and scan the library. \"\n            \"It may take a significant amount of RAM and time. Continue?\",\n        ):\n            return\n\n        args = self._get_common_args()\n\n        # Collect potential DAT locations\n        # We include the library folder itself to find DATs installed there\n        potential_roots = [\n            self._last_base / \"dats\",\n            self._last_base,\n            self._last_base.parent / \"dats\",\n            self._last_base.parent.parent / \"dats\",\n        ]\n\n        # Filter only existing directories\n        args.dats_roots = [p for p in potential_roots if p.exists()]\n\n        if not args.dats_roots:\n            self.log_msg(\n                \"Error: No DATs locations found. \"\n                \"Please run 'Update DATs' or place .dat files in the library.\"\n            )\n            return\n\n        # Clear previous results\n        self.ui.table_results.setRowCount(0)\n        self.log_msg(\"Starting full identification...\")\n\n        def _work():\n            return worker_identify_all(\n                self._last_base, args, self.log_msg, self._get_list_files_fn()\n            )\n\n        def _done(res):\n            if hasattr(res, \"results\"):\n                self.log_msg(res.text)\n                self._last_verify_results = res.results\n                self.on_verification_filter_changed()\n            else:\n                self.log_msg(str(res))\n            self._set_ui_enabled(True)\n\n        self._set_ui_enabled(False)\n        self._run_in_background(_work, _done)\n\n    def on_update_dats(self):\n        if not self._last_base:\n            self.log_msg(MSG_SELECT_BASE)\n            return\n\n        dats_dir = self._last_base / \"dats\"\n        if not dats_dir.exists():\n            self.log_msg(f\"Creating DATs directory at {dats_dir}\")\n            dats_dir.mkdir(parents=True, exist_ok=True)\n\n        # Immediate feedback\n        self.log_msg(\"Initializing DAT update process...\")\n        self.progress_hook(0.0, \"Connecting to GitHub...\")\n        self._set_ui_enabled(False)\n\n        def _work():\n            import concurrent.futures\n\n            downloader = DatDownloader(dats_dir)\n\n            # Phase 1: Listing\n            self.progress_hook(0.0, \"Fetching No-Intro file list...\")\n            ni_files = downloader.list_available_dats(\"no-intro\")\n\n            self.progress_hook(0.0, \"Fetching Redump file list...\")\n            rd_files = downloader.list_available_dats(\"redump\")\n\n            total_files = len(ni_files) + len(rd_files)\n            if total_files == 0:\n                return \"No DAT files found to download.\"\n\n            self.log_msg(\n                f\"Found {len(ni_files)} No-Intro and {len(rd_files)} Redump DATs. \"\n                \"Starting download...\"\n            )\n\n            # Phase 2: Downloading\n            completed = 0\n            success = 0\n\n            def _download_task(source, filename):\n                return downloader.download_dat(source, filename)\n\n            with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:\n                futures = []\n                # Submit No-Intro\n                for f in ni_files:\n                    futures.append(executor.submit(_download_task, \"no-intro\", f))\n                # Submit Redump\n                for f in rd_files:\n                    futures.append(executor.submit(_download_task, \"redump\", f))\n\n                for future in concurrent.futures.as_completed(futures):\n                    completed += 1\n                    percent = completed / total_files\n\n                    try:\n                        res = future.result()\n                        if res:\n                            success += 1\n                    except Exception:\n                        pass\n\n                    msg = (\n                        f\"Downloading: {completed}/{total_files} \"\n                        f\"({(percent * 100):.1f}%)\"\n                    )\n                    self.progress_hook(percent, msg)\n\n            return f\"Update complete. Downloaded {success}/{total_files} DATs.\"\n\n        def _done(res):\n            self.log_msg(str(res))\n            self._set_ui_enabled(True)\n            self.progress_hook(1.0, \"DAT update complete\")\n\n        self._run_in_background(_work, _done)\n</code></pre>"},{"location":"reference/gui/#emumanager.gui_main.MainWindowBase.log_msg","title":"<code>log_msg(text)</code>","text":"<p>Thread-safe logging method.</p> <p>Now redirects to standard logging.</p> Source code in <code>emumanager/gui_main.py</code> <pre><code>def log_msg(self, text: str):\n    \"\"\"Thread-safe logging method.\n\n    Now redirects to standard logging.\n    \"\"\"\n    logging.info(text)\n</code></pre>"},{"location":"reference/gui/#emumanager.gui_main.MainWindowBase.on_identify_selected","title":"<code>on_identify_selected()</code>","text":"<p>Identify the selected ROM using a DAT file.</p> Source code in <code>emumanager/gui_main.py</code> <pre><code>def on_identify_selected(self):\n    \"\"\"Identify the selected ROM using a DAT file.\"\"\"\n    if not self.rom_list:\n        return\n\n    sel = self.rom_list.currentItem()\n    if not sel:\n        self.log_msg(MSG_NO_ROM)\n        return\n\n    # Get file path\n    if not self._last_base:\n        self.log_msg(MSG_SELECT_BASE)\n        return\n\n    system = (\n        self.sys_list.currentItem().text() if self.sys_list.currentItem() else \"\"\n    )\n    if not system:\n        self.log_msg(MSG_NO_SYSTEM)\n        return\n\n    base_roms_dir = get_roms_dir(Path(self._last_base))\n    rom_rel_path = sel.text()\n    full_path = base_roms_dir / system / rom_rel_path\n\n    if not full_path.exists():\n        self.log_msg(f\"File not found: {full_path}\")\n        return\n\n    # Try to auto-discover DAT first\n    from emumanager.verification.dat_manager import find_dat_for_system\n\n    dat_path = None\n\n    # Look in dats folder\n    dats_dir = self._last_base / \"dats\"\n    if dats_dir.exists():\n        found = find_dat_for_system(dats_dir, system)\n        if found:\n            dat_path = str(found)\n\n    # If not found, ask user\n    if not dat_path:\n        dat_path, _ = self._qtwidgets.QFileDialog.getOpenFileName(\n            self.window,\n            \"Select DAT File\",\n            str(self._last_base),\n            \"DAT Files (*.dat *.xml)\",\n        )\n\n    if not dat_path:\n        return\n\n    self.log_msg(f\"Identifying {full_path.name} using {Path(dat_path).name}...\")\n\n    def _work():\n        return worker_identify_single_file(\n            full_path, Path(dat_path), self.log_msg, self._progress_slot\n        )\n\n    def _done(res):\n        self.log_msg(str(res))\n        self._qtwidgets.QMessageBox.information(\n            self.window, \"Identification Result\", str(res)\n        )\n\n    self._run_in_background(_work, _done)\n</code></pre>"},{"location":"reference/gui/#emumanager.gui_main.MainWindowBase.on_organize_all","title":"<code>on_organize_all()</code>","text":"<p>Organize all supported systems sequentially.</p> Source code in <code>emumanager/gui_main.py</code> <pre><code>def on_organize_all(self):\n    \"\"\"Organize all supported systems sequentially.\"\"\"\n    if not self._last_base:\n        self.log_msg(MSG_SELECT_BASE)\n        return\n\n    self._ensure_env(self._last_base)\n    args = self._get_common_args()\n    args.organize = True\n\n    self.log_msg(\"Starting batch organization...\")\n\n    def _work():\n        results = []\n\n        # 1. Distribute root files\n        # If _last_base is the 'roms' folder, we scan it directly.\n        # If _last_base is the project root, we might need to append 'roms'.\n        # Based on user log, _last_base seems to be the roms folder.\n        # But let's be safe: check if 'roms' subdir exists.\n\n        target_root = self._last_base\n        if (self._last_base / \"roms\").exists():\n            target_root = self._last_base / \"roms\"\n\n        self.log_msg(f\"Distributing files in {target_root}...\")\n        dist_stats = worker_distribute_root(\n            target_root,\n            self.log_msg,\n            progress_cb=getattr(self, \"progress_hook\", None),\n            cancel_event=self._cancel_event,\n        )\n        results.append(f\"Distribution: {dist_stats}\")\n\n        # 2. Run Switch Organizer\n        # We want to organize the 'switch' folder inside target_root\n        switch_dir = target_root / \"switch\"\n        if switch_dir.exists():\n            self.log_msg(f\"Organizing Switch folder: {switch_dir}...\")\n\n            # Create a copy of env with updated ROMS_DIR\n            switch_env = self._env.copy()\n            switch_env[\"ROMS_DIR\"] = switch_dir\n            switch_env[\"CSV_FILE\"] = switch_dir / \"biblioteca_switch.csv\"\n            switch_env[\"DUPE_DIR\"] = switch_dir / \"_DUPLICATES\"\n\n            switch_res = worker_organize(\n                switch_dir,\n                switch_env,\n                args,\n                self.log_msg,\n                self._list_files_flat,\n                progress_cb=getattr(self, \"progress_hook\", None),\n            )\n            results.append(f\"Switch: {switch_res}\")\n        else:\n            results.append(\"Switch: Skipped (folder not found)\")\n\n        return \"\\n\".join(results)\n\n    def _done(res):\n        if isinstance(res, Exception):\n            self.log_msg(f\"Batch Organization error: {res}\")\n        else:\n            self.log_msg(str(res))\n        self._set_ui_enabled(True)\n        self._update_dashboard_stats()\n\n    self._set_ui_enabled(False)\n    self._run_in_background(_work, _done)\n</code></pre>"},{"location":"reference/gui/#emumanager.gui_main.MainWindowBase.on_verify_all","title":"<code>on_verify_all()</code>","text":"<p>Verify all supported systems sequentially.</p> Source code in <code>emumanager/gui_main.py</code> <pre><code>def on_verify_all(self):\n    \"\"\"Verify all supported systems sequentially.\"\"\"\n    if not self._last_base:\n        self.log_msg(MSG_SELECT_BASE)\n        return\n    self.log_msg(\n        \"Starting batch verification (Not implemented yet for all systems)\"\n    )\n    # Placeholder\n    self.tools_controller.on_health_check()\n</code></pre>"},{"location":"reference/gui/#emumanager.gui_main.MainWindowBase.progress_hook","title":"<code>progress_hook(percent, message)</code>","text":"<p>Simple progress hook for compression helpers.</p> <p>percent: 0.0 to 1.0</p> <p>Updates the status bar and appends a short log message. Safe to be set as <code>args.progress_callback</code> in <code>switch_organizer</code>.</p> Source code in <code>emumanager/gui_main.py</code> <pre><code>def progress_hook(self, percent: float, message: str):\n    \"\"\"Simple progress hook for compression helpers.\n\n    percent: 0.0 to 1.0\n\n    Updates the status bar and appends a short log message. Safe to be set\n    as `args.progress_callback` in `switch_organizer`.\n    \"\"\"\n    if self._signaler:\n        self._signaler.progress_signal.emit(percent, message)\n    else:\n        self._progress_slot(percent, message)\n</code></pre>"},{"location":"reference/manager/","title":"Manager API","text":""},{"location":"reference/manager/#emumanager.manager","title":"<code>emumanager.manager</code>","text":"<p>Manager module</p> <p>Provides the small CLI-like API that was previously <code>scripts/emumanager.py</code>. This module lives inside the <code>emumanager</code> package so it can be imported reliably by other modules/tests.</p>"},{"location":"reference/manager/#emumanager.manager.cmd_update_dats","title":"<code>cmd_update_dats(base_dir, source=None)</code>","text":"<p>Download DAT files from Libretro database.</p> Source code in <code>emumanager/manager.py</code> <pre><code>def cmd_update_dats(base_dir: Path, source: str | None = None) -&gt; int:\n    \"\"\"Download DAT files from Libretro database.\"\"\"\n    logger = get_logger(\"manager\")\n    dats_dir = base_dir / \"dats\"\n\n    if not dats_dir.exists():\n        logger.error(f\"DATs directory not found at {dats_dir}. Run 'init' first.\")\n        return 1\n\n    downloader = DatDownloader(dats_dir)\n    sources = [source] if source else [\"no-intro\", \"redump\"]\n\n    for src in sources:\n        logger.info(f\"Checking available DATs for {src}...\")\n        available = downloader.list_available_dats(src)\n\n        if not available:\n            logger.warning(f\"No DATs found for {src}\")\n            continue\n\n        logger.info(f\"Found {len(available)} DATs for {src}. Downloading...\")\n        for filename in available:\n            # Check if already exists? For now, overwrite or skip logic could be added.\n            # We'll just download all for now as requested.\n            downloader.download_dat(src, filename)\n\n    logger.info(\"DAT update complete.\")\n    return 0\n</code></pre>"},{"location":"reference/manager/#emumanager.manager.get_roms_dir","title":"<code>get_roms_dir(base_dir)</code>","text":"<p>Resolve the roms directory given a base path.</p> <p>Handles cases where base_dir is the project root OR the roms folder itself.</p> Source code in <code>emumanager/manager.py</code> <pre><code>def get_roms_dir(base_dir: Path) -&gt; Path:\n    \"\"\"Resolve the roms directory given a base path.\n\n    Handles cases where base_dir is the project root OR the roms folder itself.\n    \"\"\"\n    # 1. If base_dir looks like the roms folder itself, prefer it.\n    # This prevents issues if a 'roms' folder accidentally exists inside\n    # the roms folder.\n    if base_dir.name == \"roms\":\n        return base_dir\n\n    # 2. If base_dir/roms exists, use it.\n    if (base_dir / \"roms\").is_dir():\n        return base_dir / \"roms\"\n\n    # 3. Fallback: assume standard structure (base/roms)\n    return base_dir / \"roms\"\n</code></pre>"},{"location":"reference/manager/#emumanager.manager.guess_system_for_file","title":"<code>guess_system_for_file(path)</code>","text":"<p>Guess the target system for a ROM file.</p> <p>Strategy: - Direct mapping by extension when unambiguous. - For ambiguous extensions (.iso, .chd, .bin, .zip, .pkg), try:   - Detect system hints from path segments (e.g., 'ps2', 'psx', 'wii').   - Detect known title IDs in filename (PS2: SLUS/SLES...; PS3: BLUS/BLES...). - Fall back to extension mapping if no better hint is found.</p> Source code in <code>emumanager/manager.py</code> <pre><code>def guess_system_for_file(path: Path) -&gt; Optional[str]:\n    \"\"\"Guess the target system for a ROM file.\n\n    Strategy:\n    - Direct mapping by extension when unambiguous.\n    - For ambiguous extensions (.iso, .chd, .bin, .zip, .pkg), try:\n      - Detect system hints from path segments (e.g., 'ps2', 'psx', 'wii').\n      - Detect known title IDs in filename (PS2: SLUS/SLES...; PS3: BLUS/BLES...).\n    - Fall back to extension mapping if no better hint is found.\n    \"\"\"\n\n    name = path.name.upper()\n    ext = path.suffix.lower()\n    mapped = EXT_TO_SYSTEM.get(ext)\n\n    # If extension maps to a specific system and is not ambiguous, return it\n    ambiguous_exts = {\".iso\", \".chd\", \".bin\", \".zip\", \".pkg\"}\n    if mapped and ext not in ambiguous_exts:\n        return mapped\n\n    # 1) Path-based hint: look for known system names in any path segment\n    system_aliases = {\n        \"psx\": \"psx\",\n        \"ps1\": \"psx\",\n        \"playstation\": \"psx\",\n        \"ps2\": \"ps2\",\n        \"ps3\": \"ps3\",\n        \"psp\": \"psp\",\n        \"psvita\": \"psvita\",\n        \"vita\": \"psvita\",\n        \"gamecube\": \"gamecube\",\n        \"gc\": \"gamecube\",\n        \"wii\": \"wii\",\n        \"wiiu\": \"wiiu\",\n        \"switch\": \"switch\",\n        \"nes\": \"nes\",\n        \"snes\": \"snes\",\n        \"megadrive\": \"megadrive\",\n        \"genesis\": \"megadrive\",\n        \"mastersystem\": \"mastersystem\",\n        \"dreamcast\": \"dreamcast\",\n        \"mame\": \"mame\",\n        \"fbneo\": \"mame\",\n        \"xbox\": \"xbox_classic\",\n        \"xbox360\": \"xbox360\",\n        \"gba\": \"gba\",\n        \"nds\": \"nds\",\n        \"n64\": \"n64\",\n        \"3ds\": \"3ds\",\n        \"neogeo\": \"neogeo\",\n    }\n    for part in path.parts:\n        alias = system_aliases.get(part.lower())\n        if alias:\n            return alias\n\n    # 2) Filename heuristics for disc identifiers\n    # PS2 serials: SLUS-xxxxx, SLES-xxxxx, SCUS-xxxxx, SCES-xxxxx, SLPS-, SLPM-, etc.\n    ps2_tags = (\n        \"SLUS-\",\n        \"SLES-\",\n        \"SCUS-\",\n        \"SCES-\",\n        \"SLPS-\",\n        \"SLPM-\",\n        \"SLKA-\",\n        \"SLED-\",\n    )\n    if any(tag in name for tag in ps2_tags):\n        return \"ps2\"\n\n    # PSP product codes: ULUS, ULES, NPJH, UCUS, etc.\n    psp_tags = (\n        \"ULUS\",\n        \"ULES\",\n        \"NPJH\",\n        \"NPUG\",\n        \"UCUS\",\n        \"ULJM\",\n        \"ULJS\",\n        \"ULKS\",\n        \"ULEM\",\n    )\n    if any(tag in name for tag in psp_tags):\n        return \"psp\"\n\n    # PS3 codes: BLUS, BLES, BCES, BLJM\n    ps3_tags = (\"BLUS\", \"BLES\", \"BCES\", \"BLJM\")\n    if any(tag in name for tag in ps3_tags):\n        return \"ps3\"\n\n    # 3) Lightweight header sniffing for GC/Wii ISOs\n    # GameCube/Wii disc IDs commonly appear at offset 0 as 6 ASCII chars.\n    # Heuristic: first char 'G' -&gt; GameCube; 'R' or 'S' -&gt; Wii.\n    if ext == \".iso\":\n        try:\n            with open(path, \"rb\") as f:\n                header = f.read(8)\n            if header and len(header) &gt;= 6:\n                disc_id = header[:6]\n                # Ensure alphanumeric uppercase pattern\n                if all((65 &lt;= b &lt;= 90) or (48 &lt;= b &lt;= 57) for b in disc_id):\n                    first = chr(disc_id[0])\n                    if first == \"G\":\n                        return \"gamecube\"\n                    if first in (\"R\", \"S\"):\n                        return \"wii\"\n        except Exception:\n            pass\n\n    # Fallback to extension mapping (may be ambiguous but better than None)\n    return mapped\n</code></pre>"},{"location":"reference/workers/","title":"Workers API","text":""},{"location":"reference/workers/#emumanager.workers.common","title":"<code>emumanager.workers.common</code>","text":""},{"location":"reference/workers/#emumanager.workers.common.GuiLogHandler","title":"<code>GuiLogHandler</code>","text":"<p>               Bases: <code>Handler</code></p> <p>Logging handler that redirects to the GUI callback.</p> Source code in <code>emumanager/workers/common.py</code> <pre><code>class GuiLogHandler(logging.Handler):\n    \"\"\"Logging handler that redirects to the GUI callback.\"\"\"\n\n    def __init__(self, log_callback: Callable[[str], None]):\n        super().__init__()\n        self.log_callback = log_callback\n\n    def emit(self, record):\n        try:\n            msg = self.format(record)\n            self.log_callback(msg)\n        except Exception:\n            self.handleError(record)\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.common.GuiLogger","title":"<code>GuiLogger</code>","text":"<p>Adapter to redirect logs to the GUI's log_msg method.</p> Source code in <code>emumanager/workers/common.py</code> <pre><code>class GuiLogger:\n    \"\"\"Adapter to redirect logs to the GUI's log_msg method.\"\"\"\n\n    def __init__(self, log_callback: Callable[[str], None]):\n        self.log_callback = log_callback\n\n    def info(self, msg, *args):\n        self.log_callback(msg % args if args else msg)\n\n    def warning(self, msg, *args):\n        self.log_callback(LOG_WARN + (msg % args if args else msg))\n\n    def error(self, msg, *args):\n        self.log_callback(LOG_ERROR + (msg % args if args else msg))\n\n    def debug(self, msg, *args):\n        pass  # Ignore debug logs in GUI by default\n\n    def exception(self, msg, *args):\n        self.log_callback(LOG_EXCEPTION + (msg % args if args else msg))\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.common.calculate_file_hash","title":"<code>calculate_file_hash(file_path, algo='md5', chunk_size=8192, progress_cb=None)</code>","text":"<p>Calculate hash of a file.</p> Source code in <code>emumanager/workers/common.py</code> <pre><code>def calculate_file_hash(\n    file_path: Path,\n    algo: str = \"md5\",\n    chunk_size: int = 8192,\n    progress_cb=None,\n) -&gt; str:\n    \"\"\"Calculate hash of a file.\"\"\"\n    h = hashlib.new(algo)\n    total_size = file_path.stat().st_size\n    processed = 0\n\n    with open(file_path, \"rb\") as f:\n        while chunk := f.read(chunk_size):\n            h.update(chunk)\n            processed += len(chunk)\n            if progress_cb:\n                progress_cb(processed / total_size)\n    return h.hexdigest()\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.common.create_file_progress_cb","title":"<code>create_file_progress_cb(main_progress_cb, start_prog, file_weight, filename)</code>","text":"<p>Creates a callback for file operations that updates the main progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>main_progress_cb</code> <code>Optional[Callable[[float, str], None]]</code> <p>The main progress callback (accepts float, str).</p> required <code>start_prog</code> <code>float</code> <p>The progress value (0.0-1.0) where this file starts.</p> required <code>file_weight</code> <code>float</code> <p>The portion of the total progress this file represents (0.0-1.0).</p> required <code>filename</code> <code>str</code> <p>The name of the file being processed.</p> required Source code in <code>emumanager/workers/common.py</code> <pre><code>def create_file_progress_cb(\n    main_progress_cb: Optional[Callable[[float, str], None]],\n    start_prog: float,\n    file_weight: float,\n    filename: str,\n):\n    \"\"\"\n    Creates a callback for file operations that updates the main progress bar.\n\n    Args:\n        main_progress_cb: The main progress callback (accepts float, str).\n        start_prog: The progress value (0.0-1.0) where this file starts.\n        file_weight: The portion of the total progress this file represents (0.0-1.0).\n        filename: The name of the file being processed.\n    \"\"\"\n    if not main_progress_cb:\n        return None\n\n    def cb(file_prog: float):\n        # Calculate total progress: start + (file_progress * weight)\n        current = start_prog + (file_prog * file_weight)\n        main_progress_cb(current, f\"Processing {filename} ({int(file_prog * 100)}%)...\")\n\n    return cb\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.common.emit_verification_result","title":"<code>emit_verification_result(per_file_cb=None, filename='', status='UNKNOWN', serial=None, title=None, md5=None, sha1=None, crc=None, **kwargs)</code>","text":"<p>Emit a standardized verification result.</p> Source code in <code>emumanager/workers/common.py</code> <pre><code>def emit_verification_result(\n    per_file_cb: Optional[Callable[[VerifyResult], None]] = None,\n    filename: str | Path = \"\",\n    status: str = \"UNKNOWN\",\n    serial: Optional[str] = None,\n    title: Optional[str] = None,\n    md5: Optional[str] = None,\n    sha1: Optional[str] = None,\n    crc: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Emit a standardized verification result.\"\"\"\n    if not per_file_cb:\n        return\n    try:\n        match_name = None\n        if title and serial:\n            match_name = f\"{title} [{serial}]\"\n        elif title:\n            match_name = title\n        elif serial:\n            match_name = f\"[{serial}]\"\n\n        fname = filename.name if isinstance(filename, Path) else str(filename)\n        fpath = str(filename) if isinstance(filename, Path) else None\n\n        res = VerifyResult(\n            filename=fname,\n            status=status,\n            match_name=match_name,\n            crc=crc,\n            sha1=sha1,\n            md5=md5,\n            sha256=None,\n            full_path=fpath,\n        )\n        per_file_cb(res)\n    except Exception:\n        pass\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.common.find_target_dir","title":"<code>find_target_dir(base_path, subdirs)</code>","text":"<p>Finds a target directory from a list of candidates relative to base_path.</p> Source code in <code>emumanager/workers/common.py</code> <pre><code>def find_target_dir(base_path: Path, subdirs: list[str]) -&gt; Optional[Path]:\n    \"\"\"Finds a target directory from a list of candidates relative to base_path.\"\"\"\n    for sub in subdirs:\n        p = base_path / sub\n        if p.exists() and p.is_dir():\n            return p\n    # Fallback: check if base_path itself matches one of the subdirs names\n    for sub in subdirs:\n        if base_path.name == Path(sub).name:\n            return base_path\n    return None\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.common.make_result_collector","title":"<code>make_result_collector(per_file_cb, results_list)</code>","text":"<p>Create a collector function that feeds both a callback and a list.</p> Source code in <code>emumanager/workers/common.py</code> <pre><code>def make_result_collector(per_file_cb, results_list):\n    \"\"\"Create a collector function that feeds both a callback and a list.\"\"\"\n\n    def _collector(d: Any, _cb=per_file_cb, _lst=results_list):\n        if callable(_cb):\n            try:\n                _cb(d)\n            except Exception:\n                pass\n        if isinstance(_lst, list):\n            _lst.append(d)\n\n    return _collector\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.common.worker_clean_junk","title":"<code>worker_clean_junk(base_path, args, log_cb, list_files_fn, list_dirs_fn)</code>","text":"<p>Worker function for cleaning junk files.</p> Source code in <code>emumanager/workers/common.py</code> <pre><code>def worker_clean_junk(\n    base_path: Path,\n    args: Any,\n    log_cb: Callable[[str], None],\n    list_files_fn: Callable[[Path], list[Path]],\n    list_dirs_fn: Callable[[Path], list[Path]],\n) -&gt; str:\n    \"\"\"Worker function for cleaning junk files.\"\"\"\n    logger = GuiLogger(log_cb)\n\n    files = list_files_fn(base_path)\n    dirs = list_dirs_fn(base_path)\n\n    progress_cb = getattr(args, \"progress_callback\", None)\n\n    deleted_files = _clean_junk_files(files, args, logger, progress_cb)\n    deleted_dirs = _clean_empty_dirs(dirs, args, logger, progress_cb)\n\n    if progress_cb:\n        progress_cb(1.0, \"Cleanup complete\")\n\n    return (\n        f\"Cleanup complete. Deleted {deleted_files} files and \"\n        f\"{deleted_dirs} empty directories.\"\n    )\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.distributor","title":"<code>emumanager.workers.distributor</code>","text":""},{"location":"reference/workers/#emumanager.workers.distributor.worker_distribute_root","title":"<code>worker_distribute_root(base_path, log_cb, progress_cb=None, cancel_event=None)</code>","text":"<p>Scans the root of base_path (roms folder) for files and moves them to their respective system subfolders based on extension/heuristics.</p> Source code in <code>emumanager/workers/distributor.py</code> <pre><code>def worker_distribute_root(\n    base_path: Path,\n    log_cb: Callable[[str], None],\n    progress_cb: Optional[Callable[[float, str], None]] = None,\n    cancel_event: Any = None,\n) -&gt; dict:\n    \"\"\"\n    Scans the root of base_path (roms folder) for files and moves them\n    to their respective system subfolders based on extension/heuristics.\n    \"\"\"\n    logger = GuiLogger(log_cb)\n    logger.info(f\"Scanning root folder for unorganized files: {base_path}\")\n\n    # Only scan files directly in base_path\n    try:\n        root_files = [f for f in base_path.iterdir() if f.is_file()]\n    except Exception as e:\n        logger.error(f\"Failed to list files in {base_path}: {e}\")\n        return {\"moved\": 0, \"skipped\": 0, \"errors\": 1}\n\n    if not root_files:\n        logger.info(\"No files found in root folder to distribute.\")\n        return {\"moved\": 0, \"skipped\": 0, \"errors\": 0}\n\n    stats = {\"moved\": 0, \"skipped\": 0, \"errors\": 0}\n    total = len(root_files)\n\n    for i, file_path in enumerate(root_files):\n        if cancel_event and cancel_event.is_set():\n            logger.warning(\"Distribution cancelled.\")\n            break\n\n        if progress_cb:\n            progress_cb(i / total, f\"Distributing: {file_path.name}\")\n\n        try:\n            # Skip hidden files or system files\n            if file_path.name.startswith(\".\") or file_path.name in [\n                \"_INSTALL_LOG.txt\",\n                \"ps2_db.csv\",\n                \"keys.txt\",\n                \"prod.keys\",\n            ]:\n                stats[\"skipped\"] += 1\n                continue\n\n            system = guess_system_for_file(file_path)\n            if system:\n                target_dir = base_path / system\n                target_dir.mkdir(parents=True, exist_ok=True)\n                target_path = target_dir / file_path.name\n\n                if target_path.exists():\n                    logger.warning(\n                        f\"File already exists in target: {target_path}. Skipping.\"\n                    )\n                    stats[\"skipped\"] += 1\n                else:\n                    logger.info(f\"Moving {file_path.name} -&gt; {system}/\")\n                    file_path.rename(target_path)\n                    stats[\"moved\"] += 1\n            else:\n                logger.warning(f\"Could not determine system for: {file_path.name}\")\n                stats[\"skipped\"] += 1\n\n        except Exception as e:\n            logger.error(f\"Error moving {file_path.name}: {e}\")\n            stats[\"errors\"] += 1\n\n    logger.info(f\"Distribution complete. Stats: {stats}\")\n    return stats\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.verification","title":"<code>emumanager.workers.verification</code>","text":""},{"location":"reference/workers/#emumanager.workers.verification.worker_hash_verify","title":"<code>worker_hash_verify(base_path, args, log_cb, list_files_fn)</code>","text":"<p>Worker function for DAT-based hash verification.</p> Source code in <code>emumanager/workers/verification.py</code> <pre><code>def worker_hash_verify(\n    base_path: Path,\n    args: Any,\n    log_cb: Callable[[str], None],\n    list_files_fn: Callable[[Path], list[Path]],\n) -&gt; VerifyReport:\n    \"\"\"Worker function for DAT-based hash verification.\"\"\"\n    logger = GuiLogger(log_cb)\n    report = VerifyReport(text=\"\")\n\n    dat_path = getattr(args, \"dat_path\", None)\n\n    # Auto-discovery logic if no specific DAT is provided\n    if not dat_path:\n        dats_roots = getattr(args, \"dats_roots\", [])\n        # Backwards compatibility\n        single_root = getattr(args, \"dats_root\", None)\n        if single_root:\n            dats_roots.append(single_root)\n\n        # Try to infer system from base_path name (e.g. \"snes\", \"ps2\")\n        system_name = base_path.name\n\n        if dats_roots and system_name:\n            logger.info(f\"Attempting to find DAT for system: {system_name}\")\n\n            # Search in all roots\n            for root in dats_roots:\n                if not root.exists():\n                    continue\n\n                found = find_dat_for_system(Path(root), system_name)\n                if found:\n                    dat_path = found\n                    logger.info(f\"Auto-selected DAT: {found.name} (in {root})\")\n                    break\n\n            if not dat_path:\n                logger.warning(\n                    f\"No matching DAT found for system '{system_name}' \"\n                    f\"in {len(dats_roots)} locations\"\n                )\n\n    if not dat_path or not Path(dat_path).exists():\n        report.text = \"Error: No valid DAT file selected or found.\"\n        return report\n\n    logger.info(f\"Parsing DAT file: {dat_path}...\")\n    try:\n        db = dat_parser.parse_dat_file(Path(dat_path))\n        logger.info(f\"DAT Loaded: {db.name} ({db.version})\")\n    except Exception as e:\n        report.text = f\"Error parsing DAT: {e}\"\n        return report\n\n    return _run_verification(base_path, db, args, logger, list_files_fn)\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.verification.worker_identify_all","title":"<code>worker_identify_all(base_path, args, log_cb, list_files_fn)</code>","text":"<p>Worker function to identify files against ALL available DATs.</p> Source code in <code>emumanager/workers/verification.py</code> <pre><code>def worker_identify_all(\n    base_path: Path,\n    args: Any,\n    log_cb: Callable[[str], None],\n    list_files_fn: Callable[[Path], list[Path]],\n) -&gt; VerifyReport:\n    \"\"\"Worker function to identify files against ALL available DATs.\"\"\"\n    logger = GuiLogger(log_cb)\n    report = VerifyReport(text=\"\")\n\n    dats_roots = getattr(args, \"dats_roots\", [])\n    # Backwards compatibility / fallback\n    single_root = getattr(args, \"dats_root\", None)\n    if single_root:\n        dats_roots.append(single_root)\n\n    # Filter existing roots\n    dats_roots = [r for r in dats_roots if r and r.exists()]\n\n    if not dats_roots:\n        report.text = \"Error: DATs directory not found.\"\n        return report\n\n    # 1. Load all DATs\n    master_db = dat_parser.DatDb()\n    master_db.name = \"Master DB\"\n\n    dat_files_set = set()\n    for root in dats_roots:\n        dat_files_set.update(root.rglob(\"*.dat\"))\n        dat_files_set.update(root.rglob(\"*.xml\"))\n\n    dat_files = sorted(list(dat_files_set))\n\n    if not dat_files:\n        report.text = \"No DAT files found.\"\n        return report\n\n    logger.info(f\"Loading {len(dat_files)} DAT files into memory...\")\n\n    progress_cb = getattr(args, \"progress_callback\", None)\n\n    for i, dat_file in enumerate(dat_files):\n        try:\n            if progress_cb:\n                progress_cb(i / len(dat_files), f\"Loading DAT: {dat_file.name}\")\n\n            db = dat_parser.parse_dat_file(dat_file)\n            dat_parser.merge_dbs(master_db, db)\n        except Exception as e:\n            logger.warning(f\"Failed to parse {dat_file.name}: {e}\")\n\n    logger.info(f\"Master DB loaded. CRC entries: {len(master_db.crc_index)}\")\n\n    return _run_verification(base_path, master_db, args, logger, list_files_fn)\n</code></pre>"},{"location":"reference/workers/#emumanager.workers.verification.worker_identify_single_file","title":"<code>worker_identify_single_file(file_path, dat_path, log_cb, progress_cb=None)</code>","text":"<p>Identify a single file against a DAT database.</p> Source code in <code>emumanager/workers/verification.py</code> <pre><code>def worker_identify_single_file(\n    file_path: Path,\n    dat_path: Path,\n    log_cb: Callable[[str], None],\n    progress_cb: Optional[Callable[[float], None]] = None,\n) -&gt; str:\n    \"\"\"Identify a single file against a DAT database.\"\"\"\n    logger = GuiLogger(log_cb)\n\n    # Initialize LibraryDB\n    lib_db = LibraryDB()\n\n    if not dat_path.exists():\n        return \"Error: DAT file not found.\"\n\n    logger.info(f\"Parsing DAT file: {dat_path}...\")\n    try:\n        db = dat_parser.parse_dat_file(dat_path)\n    except Exception as e:\n        return f\"Error parsing DAT: {e}\"\n\n    # Check DB\n    cached_hashes = {}\n    try:\n        entry = lib_db.get_entry(str(file_path.resolve()))\n        if entry:\n            st = file_path.stat()\n            if st.st_size == entry.size and abs(st.st_mtime - entry.mtime) &lt; 1.0:\n                logger.info(f\"Using cached hashes for {file_path.name}\")\n                cached_hashes = {\n                    \"crc32\": entry.crc32,\n                    \"md5\": entry.md5,\n                    \"sha1\": entry.sha1,\n                }\n    except (OSError, ValueError):\n        pass\n\n    if not cached_hashes:\n        logger.info(f\"Calculating hashes for {file_path.name}...\")\n        cached_hashes = hasher.calculate_hashes(\n            file_path, algorithms=(\"crc32\", \"md5\", \"sha1\"), progress_cb=progress_cb\n        )\n\n    crc = cached_hashes.get(\"crc32\")\n    md5 = cached_hashes.get(\"md5\")\n    sha1 = cached_hashes.get(\"sha1\")\n\n    logger.info(f\"Hashes: CRC={crc}, MD5={md5}, SHA1={sha1}\")\n\n    matches = db.lookup(crc=crc, md5=md5, sha1=sha1)\n    match = matches[0] if matches else None\n\n    # Update DB with result\n    try:\n        st = file_path.stat()\n        status = \"VERIFIED\" if match else \"UNKNOWN\"\n        match_name = match.game_name if match else None\n\n        new_entry = LibraryEntry(\n            path=str(file_path.resolve()),\n            system=\"unknown\",\n            size=st.st_size,\n            mtime=st.st_mtime,\n            crc32=crc,\n            md5=md5,\n            sha1=sha1,\n            sha256=None,\n            status=status,\n            match_name=match_name,\n            dat_name=getattr(match, \"dat_name\", None),\n        )\n        lib_db.update_entry(new_entry)\n    except OSError:\n        pass\n\n    if match:\n        return (\n            f\"MATCH FOUND!\\n\"\n            f\"Game: {match.game_name}\\n\"\n            f\"ROM:  {match.rom_name}\\n\"\n            f\"Size: {match.size} bytes\"\n        )\n    else:\n        return \"No match found in database.\"\n</code></pre>"}]}