============================= test session starts ==============================
platform linux -- Python 3.14.2, pytest-9.0.2, pluggy-1.6.0
rootdir: /home/nerton/TRABALHO/Projects/EmuManager
configfile: pyproject.toml
testpaths: tests
collected 305 items / 6 skipped

tests/test_advanced_deduplication.py ...............                     [  4%]
tests/test_analytics_dashboard.py ......................                 [ 12%]
tests/test_common_system.py ...                                          [ 13%]
tests/test_compress_rm.py ....                                           [ 14%]
tests/test_compression.py ........                                       [ 17%]
tests/test_compression_profile.py ..                                     [ 17%]
tests/test_controllers_duplicates.py ....                                [ 19%]
tests/test_controllers_tools.py .......                                  [ 21%]
tests/test_core_dat_manager.py ...                                       [ 22%]
tests/test_core_integrity.py .....                                       [ 23%]
tests/test_core_scanner.py ......                                        [ 25%]
tests/test_create_mock_roms.py ..FF                                      [ 27%]
tests/test_dat_downloader.py ...                                         [ 28%]
tests/test_dat_parser.py .....                                           [ 29%]
tests/test_dolphin_converter.py ........                                 [ 32%]
tests/test_duplicates.py ...                                             [ 33%]
tests/test_duplicates_move.py ...                                        [ 34%]
tests/test_exceptions.py .............                                   [ 38%]
tests/test_execution.py ....                                             [ 40%]
tests/test_execution_additional.py .....                                 [ 41%]
tests/test_execution_quickwins.py ...                                    [ 42%]
tests/test_fileops.py ........                                           [ 45%]
tests/test_formatting.py ......                                          [ 47%]
tests/test_gamecube_metadata.py ....                                     [ 48%]
tests/test_gamecube_provider.py ...                                      [ 49%]
tests/test_gui_logic.py ....                                             [ 50%]
tests/test_hasher.py ..                                                  [ 51%]
tests/test_integration_main.py ..                                        [ 52%]
tests/test_main_helpers.py ....                                          [ 53%]
tests/test_meta_extractor.py ...                                         [ 54%]
tests/test_meta_parser.py ...                                            [ 55%]
tests/test_n3ds_converter.py .....                                       [ 57%]
tests/test_n3ds_provider.py ...                                          [ 58%]
tests/test_nsz.py .....                                                  [ 59%]
tests/test_orchestrator_core.py ..                                       [ 60%]
tests/test_process_one_file.py ..                                        [ 60%]
tests/test_ps2_helpers.py ....                                           [ 62%]
tests/test_ps2_metadata.py ......                                        [ 64%]
tests/test_ps2_strip.py .                                                [ 64%]
tests/test_ps3_metadata.py .....                                         [ 66%]
tests/test_psp_provider.py ...                                           [ 67%]
tests/test_psx_metadata.py .....                                         [ 68%]
tests/test_quality_control.py ...................                        [ 75%]
tests/test_recompress.py ...                                             [ 76%]
tests/test_recompression_quarantine.py ....                              [ 77%]
tests/test_restored_features.py ....                                     [ 78%]
tests/test_switch_metadata.py .....                                      [ 80%]
tests/test_switch_provider.py F..                                        [ 81%]
tests/test_utils.py .........                                            [ 84%]
tests/test_validation.py ............................                    [ 93%]
tests/test_verify.py ......                                              [ 95%]
tests/test_wii_metadata.py ...                                           [ 96%]
tests/test_wii_provider.py F..                                           [ 97%]
tests/test_workers_common.py ..F.FFFF                                    [100%]

=================================== FAILURES ===================================
____________________________ test_main_default_args ____________________________

args = ()
keywargs = {'tmp_path': PosixPath('/tmp/pytest-of-nerton/pytest-7/test_main_default_args0')}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.14/unittest/mock.py:1429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'emumanager.architect'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'emumanager' has no attribute 'architect'

/usr/lib/python3.14/pkgutil.py:473: AttributeError
_____________________________ test_main_custom_dir _____________________________

args = ()
keywargs = {'tmp_path': PosixPath('/tmp/pytest-of-nerton/pytest-7/test_main_custom_dir0')}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.14/unittest/mock.py:1429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.14/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/lib/python3.14/unittest/mock.py:1411: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/lib/python3.14/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/lib/python3.14/unittest/mock.py:1487: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'emumanager.architect'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'emumanager' has no attribute 'architect'

/usr/lib/python3.14/pkgutil.py:473: AttributeError
___________ TestSwitchProvider.test_extract_metadata_categorization ____________

self = <emumanager.switch.provider.SwitchProvider object at 0x7f5c210e3b10>
path = PosixPath('game.nsp')

    def extract_metadata(self, path: Path) -> dict[str, Any]:
        """Extrai metadados de ficheiro Switch com validação robusta.
    
        Args:
            path: Caminho para o ficheiro Switch
    
        Returns:
            Dicionário com metadados (serial, title, version, category, type)
    
        Raises:
            UnsupportedFormatError: Se extensão não suportada
            FileReadError: Se não conseguir ler o ficheiro
            MetadataExtractionError: Se falhar ao extrair metadados
        """
        # Validar entrada
        try:
>           path = validate_path_exists(path, "Switch ROM path", must_be_file=True)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

emumanager/switch/provider.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('game.nsp'), name = 'Switch ROM path', must_be_file = True
must_be_dir = False

    def validate_path_exists(
        path: Path | str,
        name: str = "path",
        must_be_file: bool = False,
        must_be_dir: bool = False
    ) -> Path:
        """Valida que um caminho existe.
    
        Args:
            path: Caminho a validar
            name: Nome do parâmetro (para mensagens de erro)
            must_be_file: Se True, valida que é um ficheiro
            must_be_dir: Se True, valida que é um diretório
    
        Returns:
            Path validado e resolvido
    
        Raises:
            ValidationError: Se o caminho não existe ou tipo incorreto
        """
        if not path:
            raise ValidationError(f"{name} não pode estar vazio")
    
        p = Path(path).resolve()
    
        if not p.exists():
>           raise FileNotFoundError(str(p))
E           emumanager.common.exceptions.FileNotFoundError: Ficheiro não encontrado: /home/nerton/TRABALHO/Projects/EmuManager/game.nsp (path=/home/nerton/TRABALHO/Projects/EmuManager/game.nsp)

emumanager/common/validation.py:49: FileNotFoundError

The above exception was the direct cause of the following exception:

self = <tests.test_switch_provider.TestSwitchProvider object at 0x7f5c20fc8e10>
mock_meta = <MagicMock name='metadata' id='140033665519296'>
provider = <emumanager.switch.provider.SwitchProvider object at 0x7f5c210e3b10>

    @patch("emumanager.switch.provider.metadata")
    def test_extract_metadata_categorization(self, mock_meta, provider):
        # Case 1: Base Game
        mock_meta.get_metadata_minimal.return_value = {
            "title_id": "0100000000010000",
            "title": "Super Mario Odyssey"
        }
>       meta = provider.extract_metadata(Path("game.nsp"))
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_switch_provider.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <emumanager.switch.provider.SwitchProvider object at 0x7f5c210e3b10>
path = PosixPath('game.nsp')

    def extract_metadata(self, path: Path) -> dict[str, Any]:
        """Extrai metadados de ficheiro Switch com validação robusta.
    
        Args:
            path: Caminho para o ficheiro Switch
    
        Returns:
            Dicionário com metadados (serial, title, version, category, type)
    
        Raises:
            UnsupportedFormatError: Se extensão não suportada
            FileReadError: Se não conseguir ler o ficheiro
            MetadataExtractionError: Se falhar ao extrair metadados
        """
        # Validar entrada
        try:
            path = validate_path_exists(path, "Switch ROM path", must_be_file=True)
            validate_file_extension(path, self.get_supported_extensions())
        except Exception as e:
            if "extensão" in str(e).lower() or "extension" in str(e).lower():
                raise UnsupportedFormatError(self.system_id, path.suffix) from e
>           raise FileReadError(str(path), str(e)) from e
E           emumanager.common.exceptions.FileReadError: Ficheiro não encontrado: /home/nerton/TRABALHO/Projects/EmuManager/game.nsp (path=/home/nerton/TRABALHO/Projects/EmuManager/game.nsp) (path=game.nsp)

emumanager/switch/provider.py:56: FileReadError
____________________ TestWiiProvider.test_basic_properties _____________________

self = <tests.test_wii_provider.TestWiiProvider object at 0x7f5c20fc9090>
provider = <emumanager.wii.provider.WiiProvider object at 0x7f5c1ec78690>

    def test_basic_properties(self, provider):
>       assert provider.system_id == "wii"
E       AssertionError: assert 'dolphin' == 'wii'
E         
E         - wii
E         + dolphin

tests/test_wii_provider.py:12: AssertionError
___________________ test_gui_logger_prefix_with_correlation ____________________

    def test_gui_logger_prefix_with_correlation():
        msgs = []
    
        def cb(msg: str):
            msgs.append(msg)
    
        set_correlation_id("CID123")
        g = wc.GuiLogger(cb)
        g.info("msg %s", "A")
        g.warning("msg %s", "B")
        g.error("msg %s", "C")
        g.exception("msg %s", "D")
    
        # Each message should include the correlation id prefix
>       assert any(m.startswith("[CID123]") for m in msgs)
E       assert False
E        +  where False = any(<generator object test_gui_logger_prefix_with_correlation.<locals>.<genexpr> at 0x7f5c20fb02e0>)

tests/test_workers_common.py:50: AssertionError
___________________ test_create_file_progress_cb_calls_main ____________________

    def test_create_file_progress_cb_calls_main():
        main_calls = []
    
        def main_cb(val, text):
            main_calls.append((val, text))
    
        cb = wc.create_file_progress_cb(main_cb, 0.2, 0.5, "file.bin")
        assert cb is not None
        cb(0.5)
>       assert main_calls and main_calls[0][0] == 0.2 + (0.5 * 0.5)
E       AssertionError: assert ([(0.35, 'Processando file.bin...')] and 0.35 == (0.2 + (0.5 * 0.5)))

tests/test_workers_common.py:80: AssertionError
_____________________________ test_find_target_dir _____________________________

tmp_path = PosixPath('/tmp/pytest-of-nerton/pytest-7/test_find_target_dir0')

    def test_find_target_dir(tmp_path):
        base = tmp_path / "base"
        d1 = base / "sub1"
        d1.mkdir(parents=True)
        # should find sub1
        found = wc.find_target_dir(base, ["sub1", "sub2"])
        assert found == d1
        # if base name matches
        other = tmp_path / "match"
        other.mkdir()
        found2 = wc.find_target_dir(other, ["match", "x"])
>       assert found2 == other
E       AssertionError: assert None == PosixPath('/tmp/pytest-of-nerton/pytest-7/test_find_target_dir0/match')

tests/test_workers_common.py:94: AssertionError
_________________ test_emit_verification_result_and_collector __________________

    def test_emit_verification_result_and_collector():
        results = []
    
        def per_file(res):
            results.append(res)
    
        wc.emit_verification_result(
            per_file,
            filename=Path("rom.iso"),
            status="OK",
            title="Game",
            serial="S123",
            md5="m",
            sha1="s",
            crc="c",
        )
        assert results
        r = results[0]
>       assert r.filename == "rom.iso"
E       AssertionError: assert PosixPath('rom.iso') == 'rom.iso'
E        +  where PosixPath('rom.iso') = namespace(filename=PosixPath('rom.iso'), status='OK', title='Game', serial='S123', md5='m', sha1='s', crc='c').filename

tests/test_workers_common.py:115: AssertionError
_____________________ test_skip_if_compressed_with_fake_db _____________________

tmp_path = PosixPath('/tmp/pytest-of-nerton/pytest-7/test_skip_if_compressed_with_f0')

    def test_skip_if_compressed_with_fake_db(tmp_path):
        class FakeEntry:
            def __init__(self):
                self.status = "COMPRESSED"
    
        class FakeDB:
            def __init__(self):
                self.logged = False
    
            def get_entry(self, path):
                return FakeEntry()
    
            def log_action(self, path, code, msg):
                self.logged = True
    
        msgs = []
    
        def log_cb(m: str):
            msgs.append(m)
    
        gui_logger = wc.GuiLogger(log_cb)
        f = tmp_path / "rom.iso"
        f.write_text("x")
        db = FakeDB()
>       res = wc.skip_if_compressed(f, gui_logger, db=db)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: skip_if_compressed() got an unexpected keyword argument 'db'

tests/test_workers_common.py:154: TypeError
=========================== short test summary info ============================
FAILED tests/test_create_mock_roms.py::test_main_default_args - AttributeErro...
FAILED tests/test_create_mock_roms.py::test_main_custom_dir - AttributeError:...
FAILED tests/test_switch_provider.py::TestSwitchProvider::test_extract_metadata_categorization
FAILED tests/test_wii_provider.py::TestWiiProvider::test_basic_properties - A...
FAILED tests/test_workers_common.py::test_gui_logger_prefix_with_correlation
FAILED tests/test_workers_common.py::test_create_file_progress_cb_calls_main
FAILED tests/test_workers_common.py::test_find_target_dir - AssertionError: a...
FAILED tests/test_workers_common.py::test_emit_verification_result_and_collector
FAILED tests/test_workers_common.py::test_skip_if_compressed_with_fake_db - T...
=================== 9 failed, 296 passed, 6 skipped in 8.82s ===================
